--
--	rom.mif
--
depth = 2048;
width = 12;

content

begin

	[0..1ff] : 080;	-- nop TODO: new instruction

	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	//
	            	--	//	jvm.asm
	            	--	//
	            	--	//		JVM for JOP3
	            	--	//
	            	--	//	2001-10-24	first version works with Jopa (prime is running)
	            	--	//	2001-10-31	download of bc and ram from serial line (init)
	            	--	//	2001-11-30	change mem acces to direct
	            	--	//	2001-11-31	change to new 'class file' (in memory)
	            	--	//	2001-12-05	new shift loop
	            	--	//				nop !befor! stsp to write correct A value
	            	--	//	2001-12-06	init sp
	            	--	//	2001-12-07	only one jbr, decoding in bcfetch, i2c
	            	--	//				fixed download size
	            	--	//	2001-12-08	changes for ldp, stp instruction coding (8 bit intruction set!)
	            	--	//	2001-12-10	automatic load of bc from external memory if prog.
	            	--	//				does not fit in internal ram
	            	--	//	2002-01-16	imul, idiv, irem, ishr
	            	--	//	2002-02-25	areturn
	            	--	//	2002-03-22	use the booth hw multiplier
	            	--	//	2002-03-24	new JOP instructions shr, shl, ushr
	            	--	//				bc only in extern memory, autoincrement jpc on stbc
	            	--	//	2002-05-10	dup2
	            	--	//	2002-07-24	added special bytecodes jopsys_*
	            	--	//	2002-07-26	sys_rd/wr* from invokestatic removed
	            	--	//				method table => single word const
	            	--	//				call JVM.f() for not implemented byte codes
	            	--	//	2002-07-27	changed len field of method struct to 10 bit
	            	--	//	2002-08-02	changed max_words from 4096 to 8192
	            	--	//	2002-10-08	use JVM.java for new
	            	--	//	2002-10-11	call JVM.java for anewarray
	            	--	//	2002-10-21	added if(non)null, if_acmp
	            	--	//	2002-12-02	use new instruction wait for mem io
	            	--	//	2003-08-13	merged jvm.asm and jvmflash.asm, use C preprocessor
	            	--	//	2003-08-14	changed jbc write to a single 32 bit write (jbc does byte stuff)
	            	--	//	2003-09-11	jopsys function for save and restore of stack in RtThread.schedule()
	            	--	//	2003-09-13	invokespecial still like invokestatic
	            	--	//		Ein offenes Problem! Aber private geht jetzt.
	            	--	//				jjp and jjhp now point to first method
	            	--	//	2003-09-15	cbsf-a-load/store for String class (all array elements are one word)
	            	--	//	2003-10-06	changed max_words from 8192 to 16384, and flash address for Java
	            	--	//				program at 0x80000
	            	--	//	2003-10-23	long load_n, store_n, const_n, l2i added, ldc2_w error corretion
	            	--	//	2003-10-27	invokeinterface
	            	--	//	2004-01-18	ldc_w, pop2; float load, store and return; NOT tested!
	            	--	//	2004-02-07	null pointer check in xaload/xastore, put/getfield and invoke,
	            	--	//				array check, div/rem moved to JVM.java
	            	--	//	2004-02-12	added instruction ld_opd_8u and ld_opd_16u
	            	--	//	2004-03-12	added support for long: lreturn, lload, lstore
	            	--	//	2004-04-06	first two instructions nop because of change in fetch.vhd
	            	--	//				stjpc to nxt pipeline is now one longer (simpler mux for jbc rdaddr)
	            	--	//	2004-05-24	jopsys_invoke to call main() from Startup.boot()
	            	--	//	2004-10-08	single instruction to start mul (with a and b as operands)
	            	--	//	2004-12-11	Enhancements in array access
	            	--	//	2004-09-16	new bc read hardware (jvm_call.inc)
	            	--	//	2005-01-10	changes for bytecode cache (jvm_call.inc)
	            	--	//	2005-02-05	include version number
	            	--	//	2005-02-18	switch for simulation version
	            	--	//	2005-04-27	dup_x2
	            	--	//	2005-05-12	remove nops after mem rd/wr start. the 'io' wr
	            	--	//				generates the first bsy cycle (extension.vhd)
	            	--	//	2005-05-30	wishbone interface (extension.vhd and wb_top.vhd)
	            	--	//	2005-06-13	move newarray to JVM.java
	            	--	//				use indirection (handle) for objects and arrays
	            	--	//	2005-06-14	added multianewarray to JVM.java, version is 
	            	--	//				again without handles
	            	--	//	2005-06-20  use indirection, GC info in class struct
	            	--	//	2005-07-28	fix missing indirection bug in thread stack move (int2ext and ext2int)
	            	--	//	2005-08-13	moved null pointer check in xaload/store to check the handle!
	            	--	//	2005-08-16	new file/download format with a size field in the first word
	            	--	//	2005-08-27	added boot from USB interface (dspio board)
	            	--	//	2005-12-01	IO devices are memory mapped - no more stioa, stiod, ldiod
	            	--	//	2005-12-20	Changed dspio devices (USB) to SimpCon
	            	--	//	2006-01-11	Generate HW exception and invoke JVMHelp.exception()
	            	--	//	2006-01-12	Additional register for int. memory addressing (ar)
	            	--	//				Instructions: star, stmi, ldmi
	            	--	//				removed stioa, stiod, and ldiod
	            	--	//	2006-01-20	add get/put field/static _ref/_long
	            	--	//	2006-01-22	add type info for newarray (for long)
	            	--	//	2006-01-23	use offset instead of cp index for get/putfield
	            	--	//	2006-06-15	enhanced memory/cache interface (less cycles)
	            	--	//	2006-11-04	move mtab pointer and array length to the handle
	            	--	//				little optimization in array load/store
	            	--	//	2006-12-27	add a special bytecode for Peter's single path
	            	--	//				programming
	            	--	//	2006-12-29	2K ROM, laload, lastore enabled again, dup2_x1, dup2_x2
	            	--	//	2006-12-30	add instanceof to invoke JVM.java with constant on TOS
	            	--	//	2007-03-17	new VHDL structure: jopcpu and more records (SimpCon)
	            	--	//	2007-04-14	iaload and iastore in hardware (mem_sc.vhd)
	            	--	//	2007-05-28	putfield_ref and putstatic_ref in JVM.java
	            	--	//  2007-06-01  added multiprocessor startup (CP)
	            	--	//				aastore in JVM.java
	            	--	//	2007-06-17	new instruction jopsys_memcpy, jopsys_cond_move disabled
	            	--	//				speed-up ext2int and int2ext
	            	--	//	2007-08-31	non wrapping stack pointer, version at new address (62)
	            	--	//				start stack at 64 instead of 128
	            	--	//	2007-09-02	new instructions for hardware floating point operation with FPU
	            	--	//	2007-11-21	stack tracing enabled, more space in stack.vhd
	            	--	//				use 33 bit for the comparison (compare bug for diff > 2^31 corrected)
	            	--	//	2007-11-22	update for JOP CMP version (by CP)
	            	--	//	2007-12-03	new interrupt logic
	            	--	//	2008-02-19	WP: field access in HW
	            	--	//	2008-02-20	IO modules after the memory controller (mem_sc) to keep HWO working
	            	--	//	2008-02-24	Changed license to GPL
	            	--	//	2008-03-03	Added scratchpad RAM
	            	--	//	2008-03-04	correct MUX selection
	            	--	//	2008-03-11	Interrupt enable also in bcfetch (bug fix)
	            	--	//	2008-06-11	Remove offtbl adjustment nops
	            	--	//	2008-06-24	moncnt starts with 0, new CMP scheduler
	            	--	//	2008-06-25	WP: bug fix in cache controller
	            	--	//	2008-07-03	WP: Fixed null pointer handling of invokexxx instructions
	            	--	//	2008-07-13	MS: mapping of Native.put/getfield to jopsys version
	            	--	//	2008-08-21	MS: Corrected data out enable in SRAM/Flash interface
	            	--	//	2008-12-10	MS: static field access uses index as address
	            	--	//	... no comments ...
	            	--	//	2009-06-17	MS: Enable conditional move again
	            	--	//	2009-06-26	WP: fixed invokesuper
	            	--	//	2009-08-23	MS: start with typed memory access for data caches
	            	--	//	2009-08-24	MS: use I/O port for null pointer and array exception
	            	--	//	2009-09-05	MS: new unconditional jmp instruction
	            	--	//	2009-11-17	MS: put/getfield in mmu uses bytecode operand directly for the index
	            	--	//	2009-11-23	MS: put/getstatic support in mmu (bc operand as address)
	            	--	//	2009-11-28	MS: pufield one cycle longer for object cache hit detection, first
	            	--	//				working object cache with a single entry
	            	--	//	2010-04-24	Peter Hilber: use microcode version of aastore for RTTM
	            	--	//	2010-06-18	WP: lcmp is now in microcode
	            	--	//	2010-06-22	WP: added typed memory instructions (for split cache):
	            	--	//				stmrac	load a constant
	            	--	//				stmraf	load through fully assoc. cache
	            	--	//				stmwdf	store through fully assoc. cache
	            	--	//	2010-10-28	MS: cinval, atmstart, atmend added
	            	--	//	2011-01-07	MS: O$ with multiple objects and fields
	            	--	//
	            	--	//		idiv, irem	WRONG when one operand is 0x80000000
	            	--	//			but is now in JVM.java
	            	--	//
	            	--	//	'special' constant for a version number
	            	--	//	gets written in RAM at position 64
	            	--	//	update it when changing .asm, .inc or .vhd files
	            	--	//
	            	--	version = 20110107
	            	--	//
	            	--	//	start of stack area in the on-chip RAM
	            	--	//
	            	--	stack_init = 64
	            	--	//
	            	--	//	io address are negativ memory addresses
	            	--	//
	            	--	//	CNT=-128
	            	--	//	IO_INT_ENA=-128
	            	--	//	UART status=-112
	            	--	//	UART=-111
	            	--	//	USB status=-96
	            	--	//	USB date=-95
	            	--	//
	            	--	io_cnt = -128
	            	--	io_wd = -125
	            	--	io_exc = -124
	            	--	io_int_ena = -128
	            	--	io_status = -112
	            	--	io_uart = -111
	            	--	exc_np = 2
	            	--	exc_ab = 3
	            	--	io_lock = -123
	            	--	io_cpu_id = -122
	            	--	io_signal = -121
	            	--	usb_status = -96
	            	--	usb_data = -95
	            	--	ua_rdrf = 2
	            	--	ua_tdre = 1
	            	--	//
	            	--	//	first vars for start
	            	--	//	keep order! these vars are accessed from Java progs.
	            	--	//
	            	--	 mp ? // pointer to method struct
	            	--	 cp ? // pointer to constants
	            	--	 heap ? // start of heap
	            	--	 jjp ? // pointer to meth. table of Java JVM functions
	            	--	 jjhp ? // pointer to meth. table of Java JVM help functions
	            	--	 moncnt ? // counter for monitor
	            	--	//
	            	--	//	local vars
	            	--	//
	            	--	a ?
	            	--	b ?
	            	--	c ?
	            	--	d ?
	            	--	e ?
	            	--	f ?
	            	--	addr ? // address used for bc load from flash
	            	--	      // only in jvmflash.asm
	            	--	//
	            	--	//	JVM starts here.
	            	--	//
	            	--	//	new fetch does NOT reset address of ROM =>
	            	--	//		it starts with pc+1
	0000 : 100;		--	   nop // this gets never executed
	0001 : 100;		--	   nop // for shure during reset (perhaps two times executed)
	0002 : 0c0;		--	   ldi stack_init
	0003 : 100;		--	   nop // written in adr/read stage!
	0004 : 01b;		--	   stsp // someting strange in stack.vhd A->B !!!
	            	--	// TEST read after write
	            	--	// ldi 1
	            	--	// ldi 2
	            	--	// ldi 3
	            	--	// add
	            	--	// add
	            	--	// pop
	            	--	//////////
	            	--	// test mem interface
	            	--	//
	            	--	//			ldi 15
	            	--	//
	            	--	//			// this sequence takes 6 cycles with ram_cnt=3
	            	--	//			stmra				// start read ext. mem
	            	--	//			wait				// one for fetch
	            	--	//			wait				// one for decode
	            	--	//			ldmrd		 		// read ext. mem
	            	--	//
	            	--	//			ldi	32				// write data
	            	--	//			ldi	16				// write address
	            	--	//
	            	--	//			// this sequence takes 6 cycles with ram_cnt=3
	            	--	//			stmwa				// write ext. mem address
	            	--	//			stmwd				// write ext. mem data
	            	--	//			wait
	            	--	//			wait
	            	--	//
	            	--	//			ldi 7
	            	--	//			stmra				// start read ext. mem
	            	--	//			wait				// one for fetch
	            	--	//			wait				// one for decode
	            	--	//			ldmrd		 		// read ext. mem
	            	--	//
	            	--	//			pop
	            	--	//			pop
	            	--	/////////
	            	--	// test iaload
	            	--	//			ldi	1
	            	--	//			ldi 5
	            	--	//			stald
	            	--	//			pop
	            	--	//			wait
	            	--	//			wait
	            	--	//			ldmrd
	            	--	//			pop
	            	--	//
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop
	            	--	// test iastore
	            	--	//			ldi 1
	            	--	//			ldi 5
	            	--	//			ldi 3
	            	--	//			stast
	            	--	//			pop
	            	--	//			pop
	            	--	//			wait
	            	--	//			wait
	            	--	/////////
	            	--	// Checks whether the cpu_id != 0, waits and jumps then further down to the invoke of the boot!!!
	0005 : 0c1;		--	   ldi io_cpu_id
	0006 : 042;		--	   stmra
	0007 : 101;		--	   wait
	0008 : 101;		--	   wait
	0009 : 0e0;		--	   ldmrd
	000a : 100;		--	   nop
	000b : 197;		--	   bz cpu0_load
	000c : 100;		--	   nop
	000d : 100;		--	   nop
	            	--	cpux_loop:
	000e : 0c2;		--	   ldi io_signal
	000f : 042;		--	   stmra
	0010 : 101;		--	   wait
	0011 : 101;		--	   wait
	0012 : 0e0;		--	   ldmrd
	0013 : 100;		--	   nop
	0014 : 1b9;		--	   bz cpux_loop
	0015 : 100;		--	   nop
	0016 : 100;		--	   nop
	0017 : 0c2;		--	   ldi io_signal
	0018 : 042;		--	   stmra
	0019 : 101;		--	   wait
	001a : 101;		--	   wait
	001b : 0e0;		--	   ldmrd
	001c : 100;		--	   nop
	001d : 185;		--	   bz cpu0_load
	001e : 100;		--	   nop
	001f : 100;		--	   nop
	0020 : 243;		--	   jmp cpux_boot
	0021 : 100;		--	   nop
	0022 : 100;		--	   nop
	            	--	cpu0_load:
	            	--	//
	            	--	//
	            	--	//	download n words in extern ram (high byte first!)
	            	--	//
	0023 : 0c3;		--	   ldi 0
	0024 : 022;		--	   stm heap // word counter (ram address)
	            	--	//
	            	--	//	Variable a will be the length set by the first word.
	            	--	//	Variable c is used to assemble the word from the
	            	--	//	serial transmitted bytes.
	            	--	//
	            	--	xram_loop:
	0025 : 0c4;		--	   ldi 4 // byte counter
	            	--	ser4:
	            	--	// ************** change for load from serial line *********************
	0026 : 0c5;		--	   ldi io_status // wait for byte from uart
	0027 : 042;		--	   stmra
	0028 : 0c6;		--	   ldi ua_rdrf
	0029 : 101;		--	   wait
	002a : 101;		--	   wait
	002b : 0e0;		--	   ldmrd
	002c : 001;		--	   and
	002d : 100;		--	   nop
	002e : 1b7;		--	   bz ser4
	002f : 100;		--	   nop
	0030 : 100;		--	   nop
	0031 : 0c7;		--	   ldi io_uart // read byte from uart
	0032 : 042;		--	   stmra
	0033 : 101;		--	   wait
	0034 : 101;		--	   wait
	0035 : 0e0;		--	   ldmrd
	0036 : 0c7;		--	   ldi io_uart // write byte to uart
	0037 : 041;		--	   stmwa
	0038 : 0f8;		--	   dup // echo for down.c, 'handshake'
	0039 : 043;		--	   stmwd
	003a : 101;		--	   wait
	003b : 101;		--	   wait
	            	--	// ************** end change for load from serial line *********************
	003c : 0a8;		--	   ldm c // mem word
	003d : 0c8;		--	   ldi 8
	003e : 01d;		--	   shl
	003f : 002;		--	   or // set low byte with uart data
	0040 : 028;		--	   stm c // store 
	0041 : 0c9;		--	   ldi 1 // decrement byte counter
	0042 : 005;		--	   sub
	0043 : 0f8;		--	   dup
	0044 : 100;		--	   nop
	0045 : 1e0;		--	   bnz ser4
	0046 : 100;		--	   nop
	0047 : 100;		--	   nop
	0048 : 000;		--	   pop // remove byte counter
	0049 : 0a2;		--	   ldm heap
	004a : 041;		--	   stmwa // write ext. mem address
	004b : 0a8;		--	   ldm c
	004c : 043;		--	   stmwd // write ext. mem data
	004d : 101;		--	   wait
	004e : 101;		--	   wait
	            	--	//****
	            	--	// could be changed to load mp from ram and not from the first word!!!
	            	--	//	cleaner
	            	--	//****
	004f : 0a2;		--	   ldm heap
	0050 : 100;		--	   nop
	0051 : 1c4;		--	   bnz cnt_not_0
	0052 : 100;		--	   nop
	0053 : 100;		--	   nop
	0054 : 0a8;		--	   ldm c // first data word is the size of the application
	0055 : 026;		--	   stm a
	            	--	cnt_not_0:
	0056 : 0a2;		--	   ldm heap // mem counter
	0057 : 0c9;		--	   ldi 1 // increment
	0058 : 004;		--	   add
	0059 : 022;		--	   stm heap
	            	--	not_first:
	005a : 0a2;		--	   ldm heap
	005b : 0a6;		--	   ldm a
	005c : 003;		--	   xor
	005d : 100;		--	   nop
	005e : 185;		--	   bz cpux_boot
	005f : 100;		--	   nop
	0060 : 100;		--	   nop
	0061 : 3c3;		--	   jmp xram_loop
	0062 : 100;		--	   nop
	0063 : 100;		--	   nop
	            	--	// jump to here with cpu_id other than 0
	            	--	cpux_boot:
	            	--	//
	            	--	//	Load mp from the second word in ram.
	            	--	//
	0064 : 0c9;		--	   ldi 1
	0065 : 042;		--	   stmra
	0066 : 101;		--	   wait
	0067 : 101;		--	   wait
	0068 : 0e0;		--	   ldmrd
	0069 : 020;		--	   stm mp
	            	--	//
	            	--	//	ram is now loaded, heap points to free ram
	            	--	//	load pointer to main struct and invoke
	            	--	//
	006a : 0a0;		--	   ldm mp // pointer to 'special' pointer list
	006b : 0c9;		--	   ldi 1
	006c : 004;		--	   add
	006d : 0f8;		--	   dup
	006e : 042;		--	   stmra // read jjp
	006f : 101;		--	   wait
	0070 : 101;		--	   wait
	0071 : 0e0;		--	   ldmrd // read ext. mem
	0072 : 023;		--	   stm jjp
	0073 : 0c9;		--	   ldi 1
	0074 : 004;		--	   add
	0075 : 042;		--	   stmra // read jjhp
	0076 : 101;		--	   wait
	0077 : 101;		--	   wait
	0078 : 0e0;		--	   ldmrd // read ext. mem
	0079 : 024;		--	   stm jjhp
	007a : 0a0;		--	   ldm mp // pointer to pointer to main meth. struct
	007b : 285;		--	   jmp invoke_main // simulate invokestatic
	007c : 100;		--	   nop
	007d : 100;		--	   nop
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	//
	            	--	//	begin of jvm code
	            	--	//
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	//
	            	--	//	some special instructions that use invoke
	            	--	//
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx(int constant) for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//		with constant on stack
	            	--	//
	            	--	new:
	            	--	anewarray:
	            	--	checkcast:
	            	--	instanceof:
	            	--	//
	            	--	//	find address for JVM function
	            	--	//
	007e : 0f2;		--	   ldjpc
	007f : 0c9;		--	   ldi 1
	0080 : 005;		--	   sub
	0081 : 019;		--	   stjpc // get last byte code
	0082 : 100;		--	   nop // ???
	0083 : 100;		--	   nop // one more now (2004-04-06) ?
	0084 : 0a3;		--	   ldm jjp
	0085 : 500;		--	   nop opd
	0086 : 0f4;		--	   ld_opd_8u
	0087 : 0ca;		--	   ldi 255
	0088 : 001;		--	   and
	0089 : 0f8;		--	   dup
	008a : 004;		--	   add // *2
	008b : 004;		--	   add // jjp+2*bc
	008c : 026;		--	   stm a // save
	            	--	//
	            	--	//	get constant
	            	--	//
	008d : 4a1;		--	   ldm cp opd
	008e : 500;		--	   nop opd
	008f : 0f6;		--	   ld_opd_16u
	0090 : 004;		--	   add
	0091 : 04c;		--	   stmrac // read ext. mem, mem_bsy comes one cycle later
	0092 : 101;		--	   wait
	0093 : 101;		--	   wait
	0094 : 0e0;		--	   ldmrd // read ext. mem
	0095 : 0a6;		--	   ldm a // restore mp
	            	--	//
	            	--	//	invoke JVM.fxxx(int cons)
	            	--	//
	0096 : 26e;		--	   jmp invoke
	0097 : 100;		--	   nop
	0098 : 100;		--	   nop
	            	--	newarray:
	0099 : 500;		--	   nop opd
	009a : 0f4;		--	   ld_opd_8u
	009b : 026;		--	   stm a
	009c : 0f2;		--	   ldjpc
	009d : 0c6;		--	   ldi 2
	009e : 005;		--	   sub
	009f : 019;		--	   stjpc // get last byte code
	00a0 : 100;		--	   nop // ???
	00a1 : 100;		--	   nop // one more now (2004-04-06) ?
	00a2 : 0a6;		--	   ldm a
	00a3 : 0a3;		--	   ldm jjp
	00a4 : 500;		--	   nop opd
	00a5 : 0f4;		--	   ld_opd_8u
	00a6 : 0ca;		--	   ldi 255
	00a7 : 401;		--	   and opd // remove type info
	00a8 : 0f8;		--	   dup
	00a9 : 004;		--	   add // *2
	00aa : 004;		--	   add // jjp+2*bc
	            	--	// invoke JVM.fxxx();
	00ab : 259;		--	   jmp invoke // simulate invokestatic with ptr to meth. str. on stack
	00ac : 100;		--	   nop
	00ad : 100;		--	   nop
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx(int index) for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//		with index into constant pool on stack
	            	--	//
	            	--	putfield_ref:
	            	--	//
	            	--	// Use the write barrier in JVM.java version of putfield_ref
	            	--	//
	            	--	//	find address for JVM function
	            	--	//
	00ae : 0f2;		--	   ldjpc
	00af : 0c9;		--	   ldi 1
	00b0 : 005;		--	   sub
	00b1 : 019;		--	   stjpc // get last byte code
	00b2 : 100;		--	   nop // ???
	00b3 : 100;		--	   nop // one more now (2004-04-06) ?
	00b4 : 0a3;		--	   ldm jjp
	00b5 : 500;		--	   nop opd
	00b6 : 0f4;		--	   ld_opd_8u
	00b7 : 0ca;		--	   ldi 255
	00b8 : 001;		--	   and
	00b9 : 0f8;		--	   dup
	00ba : 004;		--	   add // *2
	00bb : 004;		--	   add // jjp+2*bc
	00bc : 026;		--	   stm a // save
	            	--	//
	            	--	//	get index
	            	--	//
	00bd : 500;		--	   nop opd
	00be : 500;		--	   nop opd
	00bf : 0f6;		--	   ld_opd_16u
	00c0 : 0a6;		--	   ldm a // restore mp
	            	--	//
	            	--	//	invoke JVM.fxxx(int index)
	            	--	//
	00c1 : 243;		--	   jmp invoke
	00c2 : 100;		--	   nop
	00c3 : 100;		--	   nop
	            	--	//
	            	--	//	this is an interrupt, (bytecode 0xf0)
	            	--	//	call com.jopdesign.sys.JVMHelp.interrupt()	(
	            	--	//		oder gleich eine f aus JVMHelp ????
	            	--	//		... JVM in Java!
	            	--	//
	            	--	putstatic_ref:
	            	--	//	find address for JVM function
	            	--	//
	00c4 : 0f2;		--	   ldjpc
	00c5 : 0c9;		--	   ldi 1
	00c6 : 005;		--	   sub
	00c7 : 019;		--	   stjpc // get last byte code
	00c8 : 100;		--	   nop // ???
	00c9 : 100;		--	   nop // one more now (2004-04-06) ?
	00ca : 0a3;		--	   ldm jjp
	00cb : 500;		--	   nop opd
	00cc : 0f4;		--	   ld_opd_8u
	00cd : 0ca;		--	   ldi 255
	00ce : 001;		--	   and
	00cf : 0f8;		--	   dup
	00d0 : 004;		--	   add // *2
	00d1 : 004;		--	   add // jjp+2*bc
	00d2 : 026;		--	   stm a // save
	            	--	//
	            	--	//	get index
	            	--	//
	00d3 : 500;		--	   nop opd
	00d4 : 500;		--	   nop opd
	00d5 : 0f6;		--	   ld_opd_16u
	00d6 : 0a6;		--	   ldm a // restore mp
	            	--	//
	            	--	//	invoke JVM.fxxx(int index)
	            	--	//
	00d7 : 22d;		--	   jmp invoke
	00d8 : 100;		--	   nop
	00d9 : 100;		--	   nop
	            	--	//
	            	--	//	this is an interrupt, (bytecode 0xf0)
	            	--	//	call com.jopdesign.sys.JVMHelp.interrupt()	(
	            	--	//		oder gleich eine f aus JVMHelp ????
	            	--	//		... JVM in Java!
	            	--	//
	            	--	sys_int:
	00da : 0f2;		--	   ldjpc // correct wrong increment on jpc
	00db : 0c9;		--	   ldi 1 //    could also be done in bcfetch.vhd
	00dc : 005;		--	   sub //    but this is simpler :-)
	00dd : 019;		--	   stjpc
	00de : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	            	--	        // method after methods inherited from Object
	00df : 225;		--	   jmp invoke // simulate invokestatic with ptr to meth. str. on stack
	00e0 : 100;		--	   nop
	00e1 : 100;		--	   nop
	            	--	//
	            	--	//	this is an exception, (bytecode 0xf1)
	            	--	//	call com.jopdesign.sys.JVMHelp.except()	(
	            	--	//
	            	--	sys_exc:
	00e2 : 0f2;		--	   ldjpc // correct wrong increment on jpc
	00e3 : 0c9;		--	   ldi 1 //    could also be done in bcfetch.vhd
	00e4 : 005;		--	   sub //    but this is simpler :-)
	00e5 : 019;		--	   stjpc
	00e6 : 0a4;		--	   ldm jjhp // interrupt() is at offset 0
	            	--	        // jjhp points in method table to first
	00e7 : 0cb;		--	   ldi 6 // forth method (index 3 * 2 word);
	00e8 : 004;		--	   add
	00e9 : 21b;		--	   jmp invoke // simulate invokestatic with ptr to meth. str. on stack
	00ea : 100;		--	   nop
	00eb : 100;		--	   nop
	            	--	//
	            	--	//	call com.jopdesign.sys.JMV.fxxx() for not implemented  byte codes.
	            	--	//		... JVM in Java!
	            	--	//
	            	--	sys_noim:
	00ec : 0f2;		--	   ldjpc
	00ed : 0c9;		--	   ldi 1
	00ee : 005;		--	   sub
	00ef : 019;		--	   stjpc // get last byte code
	00f0 : 100;		--	   nop // ???
	00f1 : 100;		--	   nop // one more now (2004-04-06) ?
	00f2 : 0a3;		--	   ldm jjp
	00f3 : 500;		--	   nop opd
	00f4 : 0f4;		--	   ld_opd_8u
	00f5 : 0ca;		--	   ldi 255
	00f6 : 001;		--	   and
	00f7 : 0f8;		--	   dup
	00f8 : 004;		--	   add // *2
	00f9 : 004;		--	   add // jjp+2*bc
	00fa : 20a;		--	   jmp invoke // simulate invokestatic with ptr to meth. str. on stack
	00fb : 100;		--	   nop
	00fc : 100;		--	   nop
	            	--	//
	            	--	//	invoke and return functions
	            	--	//
	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	//
	            	--	//	call.inc
	            	--	//
	            	--	//		include file for invoke and return functions
	            	--	//
	            	--	//	2004-08-19	extracted from jvm.asm
	            	--	//	
	            	--	//	see changlog in jvm.asm
	            	--	//
	            	--	//
	            	--	//	local vars for tmp storage
	            	--	//
	            	--	old_mp ?
	            	--	old_vp ?
	            	--	old_jpc ?
	            	--	old_cp ? // for now save it on stack
	            	--	start ?
	            	--	end ?
	            	--	args ?
	            	--	varcnt ?
	            	--	invokespecial: // is it really equivalent ????? (not really)
	            	--	      // there is an object ref on stack (but arg counts for it)
	            	--	      // is called for privat methods AND <init>!!!
	            	--	invokestatic:
	            	--	      // mp = readMem(cp+idx);
	00fd : 4a1;		--	   ldm cp opd
	00fe : 500;		--	   nop opd
	00ff : 0f6;		--	   ld_opd_16u
	0100 : 004;		--	   add
	            	--	invoke_main: // jmp with pointer to pointer to mp on TOS
	0101 : 04c;		--	   stmrac // read 'real' mp
	0102 : 101;		--	   wait
	0103 : 101;		--	   wait
	0104 : 0e0;		--	   ldmrd // read ext. mem
	            	--	jopsys_invoke: // called from Startup.boot() with pointer to main() method struct
	            	--	invoke: // jmp with mp on TOS (pointer to method struct)
	0105 : 28f;		--	   jmp invoke_vpsave
	0106 : 0f1;		--	   ldvp // save vp
	0107 : 02e;		--	   stm old_vp // in branch slots
	            	--	invokeinterface:
	0108 : 4a1;		--	   ldm cp opd
	0109 : 500;		--	   nop opd
	010a : 0f6;		--	   ld_opd_16u
	010b : 404;		--	   add opd
	010c : 44c;		--	   stmrac opd // read constant
	010d : 101;		--	   wait
	010e : 101;		--	   wait
	010f : 0e0;		--	   ldmrd // off on TOS
	0110 : 0f8;		--	   dup
	0111 : 0ca;		--	   ldi 255
	0112 : 001;		--	   and
	0113 : 026;		--	   stm a // arg count (without objectref)
	0114 : 0c8;		--	   ldi 8
	0115 : 01c;		--	   ushr
	0116 : 027;		--	   stm b // offset in method table
	0117 : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	0118 : 0c9;		--	   ldi 1 // 'real' sp
	0119 : 004;		--	   add
	011a : 0a6;		--	   ldm a
	011b : 005;		--	   sub
	011c : 01a;		--	   star // address of objectref
	011d : 100;		--	   nop
	011e : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	011f : 0f8;		--	   dup // null pointer check
	0120 : 100;		--	   nop
	0121 : 1c3;		--	   bnz interface_pointer_ok
	0122 : 0f1;		--	   ldvp // save vp in branch slot
	0123 : 02e;		--	   stm old_vp
	0124 : 242;		--	   jmp null_pointer
	            	--	interface_pointer_ok:
	0125 : 0c9;		--	   ldi 1 // at address ref+1 (in the handle) is the pointer to method table
	0126 : 004;		--	   add
	0127 : 04d;		--	   stmraf // read pointer to method table
	0128 : 101;		--	   wait
	0129 : 101;		--	   wait
	012a : 0e0;		--	   ldmrd // vt on TOS
	012b : 0c9;		--	   ldi 1 // pointer to interface table
	012c : 005;		--	   sub // befor method table
	012d : 04c;		--	   stmrac // read interface table address
	012e : 101;		--	   wait
	012f : 101;		--	   wait
	0130 : 0e0;		--	   ldmrd // it on TOS
	0131 : 0a7;		--	   ldm b
	0132 : 004;		--	   add // add offset
	0133 : 04c;		--	   stmrac // read method pointer
	0134 : 101;		--	   wait // from interface table
	0135 : 101;		--	   wait
	0136 : 0e0;		--	   ldmrd // mp on TOS
	0137 : 25d;		--	   jmp invoke_vpsave
	0138 : 100;		--	   nop
	0139 : 100;		--	   nop
	            	--	invokesuper: // this was invokespecial, replaced in JOPizer when calling super methods
	013a : 4a1;		--	   ldm cp opd
	013b : 4f8;		--	   dup opd
	013c : 0f6;		--	   ld_opd_16u
	013d : 004;		--	   add
	013e : 04c;		--	   stmrac // read constant
	013f : 101;		--	   wait
	0140 : 101;		--	   wait
	0141 : 0e0;		--	   ldmrd // read ext. mem
	0142 : 0f8;		--	   dup
	0143 : 0ca;		--	   ldi 255
	0144 : 001;		--	   and
	0145 : 026;		--	   stm a // arg count (without objectref)
	0146 : 0c8;		--	   ldi 8
	0147 : 01c;		--	   ushr
	0148 : 027;		--	   stm b // offset in method table
	0149 : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	014a : 0c9;		--	   ldi 1 // 'real' sp
	014b : 004;		--	   add
	014c : 0a6;		--	   ldm a
	014d : 005;		--	   sub
	014e : 01a;		--	   star // address of objectref
	014f : 100;		--	   nop
	0150 : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	0151 : 100;		--	   nop // null pointer check
	0152 : 100;		--	   nop
	0153 : 193;		--	   bz null_pointer
	0154 : 0f1;		--	   ldvp // save vp in branch slot
	0155 : 02e;		--	   stm old_vp
	            	--	        // cp is already loaded!
	0156 : 0c9;		--	   ldi 1 // at address cp-1 is the pointer to class structure
	0157 : 005;		--	   sub
	0158 : 04d;		--	   stmraf // read pointer to class of method
	0159 : 101;		--	   wait
	015a : 101;		--	   wait
	015b : 0e0;		--	   ldmrd // read ext. mem
	015c : 0cc;		--	   ldi 3 // superclass pointer is at offset 3
	015d : 004;		--	   add
	015e : 04c;		--	   stmrac // read pointer to superclass
	015f : 101;		--	   wait
	0160 : 101;		--	   wait
	0161 : 0e0;		--	   ldmrd // read ext. mem
	0162 : 0cd;		--	   ldi 5 // "super" method table is at superclass+5
	0163 : 004;		--	   add
	0164 : 22e;		--	   jmp invoke_addoffset
	0165 : 100;		--	   nop
	0166 : 100;		--	   nop
	            	--	//
	            	--	//	null pointer exception
	            	--	//		only used by invoke instructions
	            	--	//
	            	--	null_pointer:
	0167 : 101;		--	   wait // just for shure if we jump during
	0168 : 101;		--	   wait // a memory transaction to this point
	0169 : 0ce;		--	   ldi io_exc
	016a : 041;		--	   stmwa // write ext. mem address
	016b : 0c6;		--	   ldi exc_np
	016c : 043;		--	   stmwd // write ext. mem data
	016d : 101;		--	   wait
	016e : 101;		--	   wait
	016f : 900;		--	   nop nxt
	            	--	invokevirtual:
	0170 : 4a1;		--	   ldm cp opd
	0171 : 500;		--	   nop opd
	0172 : 0f6;		--	   ld_opd_16u
	0173 : 004;		--	   add
	0174 : 04c;		--	   stmrac // read constant
	0175 : 101;		--	   wait
	0176 : 101;		--	   wait
	0177 : 0e0;		--	   ldmrd // read ext. mem
	0178 : 0f8;		--	   dup
	0179 : 0ca;		--	   ldi 255
	017a : 001;		--	   and
	017b : 026;		--	   stm a // arg count (without objectref)
	017c : 0c8;		--	   ldi 8
	017d : 01c;		--	   ushr
	017e : 027;		--	   stm b // offset in method table
	017f : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	0180 : 0c9;		--	   ldi 1 // 'real' sp
	0181 : 004;		--	   add
	0182 : 0a6;		--	   ldm a
	0183 : 005;		--	   sub
	0184 : 01a;		--	   star // address of objectref
	0185 : 100;		--	   nop
	0186 : 0ed;		--	   ldmi // read objectref
	            	--	   // objectref is now on TOS
	0187 : 0f8;		--	   dup // null pointer check
	0188 : 100;		--	   nop
	0189 : 1c3;		--	   bnz invoke_pointer_ok
	018a : 0f1;		--	   ldvp // save vp in branch slot
	018b : 02e;		--	   stm old_vp
	018c : 3da;		--	   jmp null_pointer
	            	--	invoke_pointer_ok:
	018d : 0c9;		--	   ldi 1 // at address ref+1 (in the handle) is the pointer to method table
	018e : 004;		--	   add
	018f : 04d;		--	   stmraf // read pointer to method table
	0190 : 101;		--	   wait
	0191 : 101;		--	   wait
	0192 : 0e0;		--	   ldmrd // read ext. mem
	            	--	invoke_addoffset:
	0193 : 0a7;		--	   ldm b
	0194 : 004;		--	   add // add offset
	            	--	invoke_vpsave: // vp is allready saved in old_vp
	            	--	        // used for invokestatic and invokevirtual
	            	--	//	mp is on TOS
	            	--	//		we will not read mem[mp] now,
	            	--	//		this is done in load_bc
	0195 : 0f8;		--	   dup
	0196 : 0c9;		--	   ldi 1
	0197 : 004;		--	   add
	0198 : 04c;		--	   stmrac // read cp+arrg/locals count
	0199 : 0a0;		--	   ldm mp
	019a : 02d;		--	   stm old_mp
	019b : 020;		--	   stm mp
	019c : 101;		--	   wait
	019d : 101;		--	   wait
	019e : 0e0;		--	   ldmrd // cp...
	            	--	     // cp = readMem(mp+1);
	            	--	     // int locals = (cp>>>5) & 0x01f;
	            	--	     // int args = cp & 0x01f;
	            	--	     // cp >>>= 10;
	            	--	// get 'old' (= current) bc start address
	            	--	// and store relative jpc in stack frame
	019f : 0f2;		--	   ldjpc
	01a0 : 0e2;		--	   ldbcstart
	01a1 : 005;		--	   sub // relative pc
	01a2 : 02f;		--	   stm old_jpc
	            	--	// TODO: ldjpc and subtraction could be moved down
	            	--	// get method start address and length
	01a3 : 0a0;		--	   ldm mp
	01a4 : 04c;		--	   stmrac
	01a5 : 0a1;		--	   ldm cp
	01a6 : 030;		--	   stm old_cp
	01a7 : 101;		--	   wait
	01a8 : 101;		--	   wait
	01a9 : 0e0;		--	   ldmrd // read ext. mem
	            	--	     // int len = start & 0x03ff;
	            	--	     // start >>>= 10;
	            	--	// start bytecode load....
	01aa : 049;		--	   stbcrd
	01ab : 0f8;		--	   dup
	01ac : 0cf;		--	   ldi 31
	01ad : 001;		--	   and
	01ae : 033;		--	   stm args
	01af : 0cd;		--	   ldi 5
	01b0 : 01c;		--	   ushr
	01b1 : 0f8;		--	   dup
	01b2 : 0cf;		--	   ldi 31
	01b3 : 001;		--	   and
	01b4 : 034;		--	   stm varcnt
	01b5 : 0cd;		--	   ldi 5
	01b6 : 01c;		--	   ushr
	01b7 : 021;		--	   stm cp
	            	--	old_sp ?
	            	--	real_sp ?
	            	--	//
	            	--	// tos and tos-1 are allready written back to memory
	            	--	//
	            	--	    // int old_sp = sp-args;
	            	--	    // vp = old_sp+1;
	            	--	    // sp += varcnt;
	01b8 : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	01b9 : 0c9;		--	   ldi 1 // 'real' sp			da sp auf rd adr zeigt
	01ba : 004;		--	   add
	01bb : 0f8;		--	   dup
	01bc : 0b3;		--	   ldm args
	01bd : 005;		--	   sub
	01be : 035;		--	   stm old_sp
	01bf : 0b5;		--	   ldm old_sp
	01c0 : 0c9;		--	   ldi 1
	01c1 : 004;		--	   add
	01c2 : 018;		--	   stvp
	            	--	   // sp still on TOS
	01c3 : 0b4;		--	   ldm varcnt // 'real' varcnt (=locals-args)
	01c4 : 004;		--	   add
	01c5 : 100;		--	   nop // written in adr/read stage!
	01c6 : 01b;		--	   stsp
	01c7 : 000;		--	   pop // flush reg., sp reg is sp-2 again
	01c8 : 000;		--	   pop // could really be optimized :-(
	            	--	    // stack[++sp] = old_sp;
	            	--	    // stack[++sp] = cache.corrPc(pc);
	            	--	     // in VarBlockCache:
	            	--	     // save pc relative to start address of the method
	            	--	     // return (pc - currentBlock*blockSize) & mask;
	            	--	    // stack[++sp] = old_vp;
	            	--	    // stack[++sp] = old_cp;
	            	--	    // stack[++sp] = old_mp;
	            	--	    // 
	            	--	    // pc = cache.invoke(start, len);
	            	--	     // in VarBlockCache:
	            	--	     // test or load cache, return start address (block number * size)
	            	--	     // int off = testCache(start, len);
	            	--	     // return off;
	01c9 : 0b5;		--	   ldm old_sp
	01ca : 0af;		--	   ldm old_jpc
	            	--	// without cache load jpc here
	            	--	//		ldi 0
	            	--	//		stjpc
	            	--	// bc start address is a 'few' cycles after stbcrd available
	01cb : 0e2;		--	   ldbcstart // for future cache
	01cc : 019;		--	   stjpc
	01cd : 0ae;		--	   ldm old_vp
	01ce : 0b0;		--	   ldm old_cp
	01cf : 0ad;		--	   ldm old_mp
	            	--	// wait on bytecode load from memory system
	01d0 : 101;		--	   wait
	01d1 : 101;		--	   wait
	01d2 : 900;		--	   nop nxt
	            	--	// end load_bc
	            	--	//
	            	--	//	thats the pipeline delay from stjpc - jpc -
	            	--	//	rdaddress - jpaddr - pc!
	            	--	//
	            	--	//		could be simpler if a different command to store
	            	--	//		write address for jbc (or use DMA in mem.vhd!)
	            	--	//
	            	--	//			stjpc
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop
	            	--	//			nop	nxt
	            	--	//
	            	--	areturn:
	            	--	freturn:
	            	--	ireturn:
	01d3 : 026;		--	   stm a // store return value
	01d4 : 0f8;		--	   dup // mp is on tos
	01d5 : 04c;		--	   stmrac
	01d6 : 020;		--	   stm mp
	01d7 : 021;		--	   stm cp
	01d8 : 018;		--	   stvp
	01d9 : 101;		--	   wait // wait for mem(mp)
	01da : 101;		--	   wait
	01db : 0e0;		--	   ldmrd // read ext. mem
	01dc : 049;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	01dd : 02f;		--	   stm old_jpc // save realtive pc
	01de : 100;		--	   nop // written in adr/read stage!
	01df : 01b;		--	   stsp // last is new sp
	01e0 : 000;		--	   pop // flash tos, tos-1 (registers)
	01e1 : 000;		--	   pop // sp must be two lower, points to rd adr
	01e2 : 0e2;		--	   ldbcstart // start block of method
	01e3 : 0af;		--	   ldm old_jpc // plus relative jpc
	01e4 : 004;		--	   add
	01e5 : 019;		--	   stjpc
	01e6 : 0a6;		--	   ldm a // load return value
	            	--	// wait on bytecode load from memory system
	01e7 : 101;		--	   wait
	01e8 : 101;		--	   wait
	01e9 : 900;		--	   nop nxt
	            	--	dreturn:
	            	--	lreturn:
	01ea : 026;		--	   stm a // store return value
	01eb : 027;		--	   stm b
	01ec : 0f8;		--	   dup // mp is on tos
	01ed : 04c;		--	   stmrac
	01ee : 020;		--	   stm mp
	01ef : 021;		--	   stm cp
	01f0 : 018;		--	   stvp
	01f1 : 101;		--	   wait // wait for mem(mp)
	01f2 : 101;		--	   wait
	01f3 : 0e0;		--	   ldmrd // read ext. mem
	01f4 : 049;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	01f5 : 02f;		--	   stm old_jpc // save realtive pc
	01f6 : 100;		--	   nop // written in adr/read stage!
	01f7 : 01b;		--	   stsp // last is new sp
	01f8 : 000;		--	   pop // flash tos, tos-1 (registers)
	01f9 : 000;		--	   pop // sp must be two lower, points to rd adr
	01fa : 0e2;		--	   ldbcstart // start block of method
	01fb : 0af;		--	   ldm old_jpc // plus relative jpc
	01fc : 004;		--	   add
	01fd : 019;		--	   stjpc
	01fe : 0a7;		--	   ldm b
	01ff : 0a6;		--	   ldm a // load return value
	            	--	// wait on bytecode load from memory system
	0200 : 101;		--	   wait
	0201 : 101;		--	   wait
	0202 : 900;		--	   nop nxt
	            	--	return:
	            	--	    // mp = stack[sp--];
	            	--	    // cp = stack[sp--];
	            	--	    // vp = stack[sp--];
	            	--	    // pc = stack[sp--];
	            	--	    // sp = stack[sp--];
	            	--	    // 
	            	--	    // int start = readMem(mp);
	            	--	    // int len = start & 0x03ff;
	            	--	    // start >>>= 10;
	            	--	    // pc = cache.ret(start, len, pc);
	            	--	     // in VarBlockCache:
	            	--	     // int off = testCache(start, len);
	            	--	     // return (off+pc) & mask;
	0203 : 0f8;		--	   dup // mp is on tos
	0204 : 04c;		--	   stmrac
	0205 : 020;		--	   stm mp
	0206 : 021;		--	   stm cp
	0207 : 018;		--	   stvp
	0208 : 101;		--	   wait // wait for mem(mp)
	0209 : 101;		--	   wait
	020a : 0e0;		--	   ldmrd // read ext. mem
	020b : 049;		--	   stbcrd // start bytecode load
	            	--	//			stjpc
	020c : 02f;		--	   stm old_jpc // save realtive pc
	020d : 100;		--	   nop // written in adr/read stage!
	020e : 01b;		--	   stsp // last is new sp
	020f : 0e2;		--	   ldbcstart // start block of method
	0210 : 0af;		--	   ldm old_jpc // plus relative jpc
	0211 : 004;		--	   add
	0212 : 019;		--	   stjpc
	0213 : 000;		--	   pop // flash tos, tos-1 (registers)
	0214 : 000;		--	   pop // sp must be two lower, points to rd adr
	            	--	// wait on bytecode load from memory system
	0215 : 101;		--	   wait
	0216 : 101;		--	   wait
	0217 : 900;		--	   nop nxt
	            	--	// end load_bc
	            	--	///////////////////////////////////////////////////////////////////////////
	            	--	//
	            	--	//	begin of simple bytecodes
	            	--	//
	            	--	///////////////////////////////////////////////////////////////////////////
	0218 : 900;		--	nop: nop nxt
	0219 : 8d0;		--	iconst_m1: ldi -1 nxt
	            	--	fconst_0:
	            	--	aconst_null:
	021a : 8c3;		--	iconst_0: ldi 0 nxt
	021b : 8c9;		--	iconst_1: ldi 1 nxt
	021c : 8c6;		--	iconst_2: ldi 2 nxt
	021d : 8cc;		--	iconst_3: ldi 3 nxt
	021e : 8c4;		--	iconst_4: ldi 4 nxt
	021f : 8cd;		--	iconst_5: ldi 5 nxt
	0220 : 500;		--	bipush: nop opd
	0221 : 8f5;		--	   ld_opd_8s nxt
	0222 : 500;		--	sipush: nop opd
	0223 : 500;		--	   nop opd
	0224 : 8f7;		--	   ld_opd_16s nxt
	0225 : 4a1;		--	ldc: ldm cp opd
	0226 : 0f4;		--	   ld_opd_8u
	0227 : 004;		--	   add
	0228 : 04c;		--	   stmrac // read ext. mem, mem_bsy comes one cycle later
	0229 : 101;		--	   wait
	022a : 101;		--	   wait
	022b : 8e0;		--	   ldmrd nxt // read ext. mem
	            	--	ldc_w:
	022c : 4a1;		--	   ldm cp opd
	022d : 500;		--	   nop opd
	022e : 0f6;		--	   ld_opd_16u
	022f : 004;		--	   add
	0230 : 04c;		--	   stmrac // read ext. mem, mem_bsy comes one cycle later
	0231 : 101;		--	   wait
	0232 : 101;		--	   wait
	0233 : 8e0;		--	   ldmrd nxt // read ext. mem
	            	--	aload:
	            	--	fload:
	0234 : 500;		--	iload: nop opd
	0235 : 8ec;		--	   ld nxt
	            	--	aload_0:
	            	--	fload_0:
	0236 : 8e8;		--	iload_0: ld0 nxt
	            	--	aload_1:
	            	--	fload_1:
	0237 : 8e9;		--	iload_1: ld1 nxt
	            	--	aload_2:
	            	--	fload_2:
	0238 : 8ea;		--	iload_2: ld2 nxt
	            	--	aload_3:
	            	--	fload_3:
	0239 : 8eb;		--	iload_3: ld3 nxt
	            	--	astore:
	            	--	fstore:
	023a : 500;		--	istore: nop opd
	023b : 814;		--	   st nxt
	            	--	astore_0:
	            	--	fstore_0:
	023c : 810;		--	istore_0: st0 nxt
	            	--	astore_1:
	            	--	fstore_1:
	023d : 811;		--	istore_1: st1 nxt
	            	--	astore_2:
	            	--	fstore_2:
	023e : 812;		--	istore_2: st2 nxt
	            	--	astore_3:
	            	--	fstore_3:
	023f : 813;		--	istore_3: st3 nxt
	0240 : 800;		--	pop: pop nxt
	0241 : 000;		--	pop2: pop
	0242 : 800;		--	   pop nxt
	0243 : 8f8;		--	dup: dup nxt
	0244 : 026;		--	dup_x1: stm a
	0245 : 027;		--	   stm b
	0246 : 0a6;		--	   ldm a
	0247 : 0a7;		--	   ldm b
	0248 : 8a6;		--	   ldm a nxt
	0249 : 026;		--	dup_x2: stm a
	024a : 027;		--	   stm b
	024b : 028;		--	   stm c
	024c : 0a6;		--	   ldm a
	024d : 0a8;		--	   ldm c
	024e : 0a7;		--	   ldm b
	024f : 8a6;		--	   ldm a nxt
	0250 : 026;		--	dup2: stm a
	0251 : 027;		--	   stm b
	0252 : 0a7;		--	   ldm b
	0253 : 0a6;		--	   ldm a
	0254 : 0a7;		--	   ldm b
	0255 : 8a6;		--	   ldm a nxt
	0256 : 026;		--	dup2_x1: stm a
	0257 : 027;		--	   stm b
	0258 : 028;		--	   stm c
	0259 : 0a7;		--	   ldm b
	025a : 0a6;		--	   ldm a
	025b : 0a8;		--	   ldm c
	025c : 0a7;		--	   ldm b
	025d : 8a6;		--	   ldm a nxt
	025e : 026;		--	dup2_x2: stm a
	025f : 027;		--	   stm b
	0260 : 028;		--	   stm c
	0261 : 029;		--	   stm d
	0262 : 0a7;		--	   ldm b
	0263 : 0a6;		--	   ldm a
	0264 : 0a9;		--	   ldm d
	0265 : 0a8;		--	   ldm c
	0266 : 0a7;		--	   ldm b
	0267 : 8a6;		--	   ldm a nxt
	0268 : 026;		--	swap: stm a // not tested, javac does not generate it!
	0269 : 027;		--	   stm b
	026a : 0a6;		--	   ldm a
	026b : 8a7;		--	   ldm b nxt
	026c : 804;		--	iadd: add nxt
	026d : 805;		--	isub: sub nxt
	            	--	ineg:
	026e : 0d0;		--	   ldi -1
	026f : 003;		--	   xor
	0270 : 0c9;		--	   ldi 1
	0271 : 804;		--	   add nxt
	0272 : 801;		--	iand: and nxt
	0273 : 802;		--	ior: or nxt
	0274 : 803;		--	ixor: xor nxt
	0275 : 81d;		--	ishl: shl nxt
	0276 : 81e;		--	ishr: shr nxt
	0277 : 81c;		--	iushr: ushr nxt
	            	--	imul:
	0278 : 040;		--	   stmul // store both operands and start
	0279 : 000;		--	   pop // pop second operand
	027a : 0c6;		--	   ldi 2 // 2*7+2 wait ok!
	            	--	imul_loop:
	027b : 0d0;		--	   ldi -1
	027c : 004;		--	   add
	027d : 0f8;		--	   dup
	027e : 100;		--	   nop
	027f : 1fb;		--	   bnz imul_loop
	0280 : 100;		--	   nop
	0281 : 100;		--	   nop
	0282 : 000;		--	   pop // remove counter
	0283 : 8e1;		--	   ldmul nxt
	            	--	// 	moved to JVM.java
	            	--	// 
	            	--	// idiv:
	            	--	// 			stm	b
	            	--	// 			stm	a
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make a positiv
	            	--	// 			nop
	            	--	// 			bz	idiv_apos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	a
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// idiv_apos:
	            	--	// 			ldm	b
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make b positiv
	            	--	// 			nop
	            	--	// 			bz	idiv_bpos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	b
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	b
	            	--	// idiv_bpos:
	            	--	// 			xor					//	sign
	            	--	// 			stm	e
	            	--	// 
	            	--	// 			ldi	0
	            	--	// 			stm	c			//	c is quotient
	            	--	// 			ldi	0
	            	--	// 			stm	d			//	d is remainder
	            	--	// 			ldi	32			//	loop counter
	            	--	// idiv_loop:
	            	--	// 			ldm	c
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	c
	            	--	// 			ldm	d
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	d
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bz	idiv_noor
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	d
	            	--	// idiv_noor:
	            	--	// 			ldm	a
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bnz	idiv_nosub
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	// 			stm	d
	            	--	// 			ldm	c
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	c
	            	--	// idiv_nosub:
	            	--	// 
	            	--	// 			ldi	1
	            	--	// 			sub
	            	--	// 			dup
	            	--	// 			nop
	            	--	// 			bnz	idiv_loop
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			pop				// remove loop counter
	            	--	// 			ldm	e
	            	--	// 			nop
	            	--	// 			bz	idiv_nosign
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	c
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add	nxt
	            	--	// idiv_nosign:
	            	--	// 			ldm	c	nxt
	            	--	// 
	            	--	// irem:
	            	--	// 			stm	b
	            	--	// 			stm	a
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			dup					// make a positiv
	            	--	// 			stm	e				//	sign
	            	--	// 			nop
	            	--	// 			bz	irem_apos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	a
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// irem_apos:
	            	--	// 			ldm	b
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and					// make b positiv
	            	--	// 			nop
	            	--	// 			bz	irem_bpos
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	b
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add
	            	--	// 			stm	b
	            	--	// irem_bpos:
	            	--	// 
	            	--	// 			ldi	0
	            	--	// 			stm	c			//	c is quotient
	            	--	// 			ldi	0
	            	--	// 			stm	d			//	d is remainder
	            	--	// 			ldi	32			//	loop counter
	            	--	// irem_loop:
	            	--	// 			ldm	c
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	c
	            	--	// 			ldm	d
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	d
	            	--	// 			ldm	a
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bz	irem_noor
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	d
	            	--	// irem_noor:
	            	--	// 			ldm	a
	            	--	// 			dup
	            	--	// 			add
	            	--	// 			stm	a
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	//         	ldi	-2147483648		//  0x80000000
	            	--	// 			and
	            	--	// 			nop
	            	--	// 			bnz	irem_nosub
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldm	b
	            	--	// 			sub
	            	--	// 			stm	d
	            	--	// 			ldm	c
	            	--	// 			ldi	1
	            	--	// 			or
	            	--	// 			stm	c
	            	--	// irem_nosub:
	            	--	// 
	            	--	// 			ldi	1
	            	--	// 			sub
	            	--	// 			dup
	            	--	// 			nop
	            	--	// 			bnz	irem_loop
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			pop				// remove loop counter
	            	--	// 			ldm	e
	            	--	// 			nop
	            	--	// 			bz	irem_nosign
	            	--	// 			nop
	            	--	// 			nop
	            	--	// 			ldm	d
	            	--	// 			ldi -1
	            	--	// 			xor
	            	--	// 			ldi 1
	            	--	// 			add	nxt
	            	--	// irem_nosign:
	            	--	// 			ldm	d	nxt
	            	--	// 
	            	--	// Floating point operations in HW with FPU
	            	--	iinc:
	0284 : 4f1;		--	   ldvp opd
	0285 : 0f4;		--	   ld_opd_8u
	0286 : 004;		--	   add
	0287 : 41a;		--	   star opd
	0288 : 0f5;		--	   ld_opd_8s
	0289 : 0ed;		--	   ldmi
	028a : 004;		--	   add
	028b : 815;		--	   stmi nxt
	            	--	i2c:
	028c : 0d1;		--	   ldi 65535
	028d : 801;		--	   and nxt
	            	--	ifnull:
	            	--	ifnonnull:
	            	--	ifeq:
	            	--	ifne:
	            	--	iflt:
	            	--	ifge:
	            	--	ifgt:
	            	--	ifle:
	028e : 500;		--	   nop opd
	028f : 502;		--	   jbr opd
	0290 : 000;		--	   pop
	0291 : 900;		--	   nop nxt
	            	--	if_acmpeq:
	            	--	if_acmpne:
	            	--	if_icmpeq:
	            	--	if_icmpne:
	            	--	if_icmplt:
	            	--	if_icmpge:
	            	--	if_icmpgt:
	            	--	if_icmple:
	0292 : 500;		--	   nop opd
	0293 : 502;		--	   jbr opd
	0294 : 000;		--	   pop
	0295 : 800;		--	   pop nxt
	            	--	goto:
	0296 : 500;		--	   nop opd
	0297 : 502;		--	   jbr opd
	0298 : 100;		--	   nop
	0299 : 900;		--	   nop nxt
	            	--	getstatic_ref:
	            	--	getstatic: // address is in index (bc opd)
	029a : 510;		--	   stgs opd
	029b : 500;		--	   nop opd
	029c : 101;		--	   wait
	029d : 101;		--	   wait
	029e : 8e0;		--	   ldmrd nxt
	            	--	jopsys_getstatic:
	029f : 04a;		--	   stidx
	02a0 : 110;		--	   stgs
	02a1 : 101;		--	   wait
	02a2 : 101;		--	   wait
	02a3 : 8e0;		--	   ldmrd nxt
	            	--	putstatic: // address is in index (bc opd)
	02a4 : 44b;		--	   stps opd // MMU uses bc opd
	02a5 : 500;		--	   nop opd
	02a6 : 101;		--	   wait
	02a7 : 101;		--	   wait
	02a8 : 900;		--	   nop nxt
	            	--	jopsys_putstatic:
	02a9 : 04a;		--	   stidx
	02aa : 04b;		--	   stps
	02ab : 101;		--	   wait
	02ac : 101;		--	   wait
	02ad : 900;		--	   nop nxt
	            	--	getfield_ref: // getfield for reference is the same
	            	--	getfield:
	02ae : 446;		--	   stgf opd // let the HW do the work
	02af : 500;		--	   nop opd // index is loaded from BC operand
	            	--	   // could the opd go to the wait instruction?
	            	--	   // No, it breaks wait :-(
	02b0 : 101;		--	   wait
	02b1 : 101;		--	   wait
	02b2 : 8e0;		--	   ldmrd nxt // read result
	            	--	jopsys_getfield: // version from Native
	02b3 : 04a;		--	   stidx
	02b4 : 046;		--	   stgf // let the HW do the work
	02b5 : 101;		--	   wait
	02b6 : 101;		--	   wait
	02b7 : 8e0;		--	   ldmrd nxt // read result
	            	--	putfield:
	02b8 : 047;		--	   stpf // start putfield index is taken from the BC operand
	02b9 : 500;		--	   nop opd
	02ba : 500;		--	   nop opd // get rid of second stack location
	02bb : 101;		--	   wait
	02bc : 101;		--	   wait
	02bd : 800;		--	   pop nxt
	            	--	   // TODO: change order between value and index in Native
	            	--	jopsys_putfield: // Version from Native
	02be : 026;		--	   stm a
	02bf : 04a;		--	   stidx
	02c0 : 0a6;		--	   ldm a
	02c1 : 047;		--	   stpf // let the HW do the work
	02c2 : 101;		--	   wait
	02c3 : 101;		--	   wait
	02c4 : 800;		--	   pop nxt
	            	--	arraylength:
	02c5 : 0c9;		--	   ldi 1
	02c6 : 004;		--	   add // arrayref+1 (in handle)
	02c7 : 04d;		--	   stmraf // read ext. mem, mem_bsy comes one cycle later
	02c8 : 101;		--	   wait
	02c9 : 101;		--	   wait
	02ca : 8e0;		--	   ldmrd nxt // read ext. mem
	            	--	//aastore: is now in JVM.java for the write barrier
	            	--	bastore:
	            	--	castore:
	            	--	fastore:
	            	--	iastore:
	            	--	sastore:
	02cb : 045;		--	   stast
	02cc : 000;		--	   pop
	02cd : 000;		--	   pop
	02ce : 101;		--	   wait
	02cf : 101;		--	   wait
	02d0 : 900;		--	   nop nxt
	            	--	aaload:
	            	--	baload:
	            	--	caload:
	            	--	faload:
	            	--	iaload:
	            	--	saload:
	02d1 : 044;		--	   stald
	02d2 : 000;		--	   pop
	02d3 : 101;		--	   wait
	02d4 : 101;		--	   wait
	02d5 : 8e0;		--	   ldmrd nxt
	            	--	monitorenter:
	02d6 : 000;		--	    pop // drop reference
	            	--	//			bz null_pointer		// null pointer check
	02d7 : 0d2;		--	   ldi io_int_ena
	02d8 : 041;		--	   stmwa // write ext. mem address
	02d9 : 0c3;		--	   ldi 0
	02da : 043;		--	   stmwd // write ext. mem data
	02db : 0a5;		--	   ldm moncnt
	02dc : 0c9;		--	   ldi 1
	02dd : 004;		--	   add
	02de : 101;		--	   wait
	02df : 101;		--	   wait
	02e0 : 111;		--	   cinval // invalidate earlier, just in case
	02e1 : 025;		--	   stm moncnt
	            	--	   // request the global lock
	02e2 : 0d3;		--	   ldi io_lock
	02e3 : 041;		--	   stmwa // write ext. mem address
	02e4 : 0c9;		--	   ldi 1
	02e5 : 043;		--	   stmwd // write ext. mem data
	02e6 : 101;		--	   wait
	02e7 : 101;		--	   wait
	02e8 : 900;		--	   nop nxt
	            	--	monitorexit:
	02e9 : 000;		--	   pop // drop reference
	            	--	//			bz null_pointer		// null pointer check
	02ea : 0a5;		--	   ldm moncnt
	02eb : 0c9;		--	   ldi 1
	02ec : 005;		--	   sub
	02ed : 0f8;		--	   dup
	02ee : 025;		--	   stm moncnt
	02ef : 1cc;		--	   bnz mon_no_ena
	            	--	   // can be exec in in branch delay?
	            	--	   // up to now yes, but we change the write
	            	--	   // some time....
	            	--	   // nop
	            	--	   // nop
	            	--	   // free the global lock
	02f0 : 0d3;		--	   ldi io_lock
	02f1 : 041;		--	   stmwa // write ext. mem address
	02f2 : 0c3;		--	   ldi 0
	02f3 : 043;		--	   stmwd // write ext. mem data
	02f4 : 101;		--	   wait
	02f5 : 101;		--	   wait
	02f6 : 0d2;		--	   ldi io_int_ena
	02f7 : 041;		--	   stmwa
	02f8 : 0c9;		--	   ldi 1
	02f9 : 043;		--	   stmwd // write ext. mem data
	02fa : 101;		--	   wait
	02fb : 101;		--	   wait
	02fc : 900;		--	mon_no_ena: nop nxt
	            	--	//		
	            	--	// long bytecodes
	            	--	//
	            	--	//
	            	--	//  This file is a part of JOP, the Java Optimized Processor
	            	--	//
	            	--	//  Copyright (C) 2001-2008, Martin Schoeberl (martin@jopdesign.com)
	            	--	//
	            	--	//  This program is free software: you can redistribute it and/or modify
	            	--	//  it under the terms of the GNU General Public License as published by
	            	--	//  the Free Software Foundation, either version 3 of the License, or
	            	--	//  (at your option) any later version.
	            	--	//
	            	--	//  This program is distributed in the hope that it will be useful,
	            	--	//  but WITHOUT ANY WARRANTY; without even the implied warranty of
	            	--	//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	            	--	//  GNU General Public License for more details.
	            	--	//
	            	--	//  You should have received a copy of the GNU General Public License
	            	--	//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	            	--	//
	            	--	//
	            	--	//	Include file for long bytecodes
	            	--	//
	            	--	//	Arrangement of longs in the memory:
	            	--	//		as usual in Java - high word first (at lower address)
	            	--	//		thet stack grows to higher addresses => TOS is LOWER part
	            	--	//		of long!
	            	--	// lreturn: is in jvm_call.inc
	            	--	ldc2_w:
	02fd : 4a1;		--	   ldm cp opd
	02fe : 500;		--	   nop opd
	02ff : 0f6;		--	   ld_opd_16u
	0300 : 004;		--	   add
	0301 : 0f8;		--	   dup
	0302 : 04c;		--	   stmrac // read ext. mem, mem_bsy comes one cycle later
	0303 : 0c9;		--	   ldi 1
	0304 : 004;		--	   add // address for next word
	0305 : 101;		--	   wait
	0306 : 101;		--	   wait
	0307 : 0e0;		--	   ldmrd // first word
	0308 : 026;		--	   stm a
	0309 : 04c;		--	   stmrac // read ext. mem, mem_bsy comes one cycle later
	030a : 0a6;		--	   ldm a // first word again on stack
	030b : 101;		--	   wait
	030c : 101;		--	   wait
	030d : 8e0;		--	   ldmrd nxt // second word
	            	--	dconst_0:
	030e : 0c3;		--	lconst_0: ldi 0
	030f : 8c3;		--	   ldi 0 nxt
	0310 : 0c3;		--	lconst_1: ldi 0
	0311 : 8c9;		--	   ldi 1 nxt // TOS is low part
	0312 : 026;		--	l2i: stm a // low part
	0313 : 000;		--	   pop // drop high word
	0314 : 8a6;		--	   ldm a nxt // low on stack
	0315 : 0f8;		--	i2l: dup
	0316 : 026;		--	   stm a
	0317 : 0cf;		--	   ldi 31
	0318 : 01e;		--	   shr // high part is a >> 31
	0319 : 8a6;		--	   ldm a nxt // low part is a
	            	--	dload_0:
	031a : 0e8;		--	lload_0: ld0 // high word
	031b : 8e9;		--	   ld1 nxt // low word
	            	--	dload_1:
	031c : 0e9;		--	lload_1: ld1
	031d : 8ea;		--	   ld2 nxt
	            	--	dload_2:
	031e : 0ea;		--	lload_2: ld2
	031f : 8eb;		--	   ld3 nxt
	            	--	dload_3:
	0320 : 0f1;		--	lload_3: ldvp // there is no ld4
	0321 : 0f8;		--	   dup
	0322 : 0c9;		--	   ldi 1
	0323 : 004;		--	   add
	0324 : 018;		--	   stvp
	0325 : 026;		--	   stm a
	0326 : 0ea;		--	   ld2
	0327 : 0eb;		--	   ld3
	0328 : 0a6;		--	   ldm a // restore vp
	0329 : 018;		--	   stvp
	032a : 900;		--	   nop nxt
	            	--	dload:
	032b : 0f1;		--	lload: ldvp
	032c : 4f8;		--	   dup opd
	032d : 0f4;		--	   ld_opd_8u
	032e : 004;		--	   add
	032f : 018;		--	   stvp
	0330 : 026;		--	   stm a
	0331 : 0e8;		--	   ld0
	0332 : 0e9;		--	   ld1
	0333 : 0a6;		--	   ldm a
	0334 : 018;		--	   stvp
	0335 : 900;		--	   nop nxt
	            	--	dstore_0:
	0336 : 011;		--	lstore_0: st1 // low word
	0337 : 810;		--	   st0 nxt // high word
	            	--	dstore_1:
	0338 : 012;		--	lstore_1: st2
	0339 : 811;		--	   st1 nxt
	            	--	dstore_2:
	033a : 013;		--	lstore_2: st3
	033b : 812;		--	   st2 nxt
	            	--	dstore_3:
	033c : 0f1;		--	lstore_3: ldvp // there is no ld4
	033d : 0f8;		--	   dup
	033e : 0c9;		--	   ldi 1
	033f : 004;		--	   add
	0340 : 018;		--	   stvp
	0341 : 026;		--	   stm a
	0342 : 013;		--	   st3
	0343 : 012;		--	   st2
	0344 : 0a6;		--	   ldm a // restore vp
	0345 : 018;		--	   stvp
	0346 : 900;		--	   nop nxt
	            	--	dstore:
	0347 : 0f1;		--	lstore: ldvp
	0348 : 4f8;		--	   dup opd
	0349 : 0f4;		--	   ld_opd_8u
	034a : 004;		--	   add
	034b : 018;		--	   stvp
	034c : 026;		--	   stm a
	034d : 011;		--	   st1
	034e : 010;		--	   st0
	034f : 0a6;		--	   ldm a
	0350 : 018;		--	   stvp
	0351 : 900;		--	   nop nxt
	            	--	getstatic_long:
	            	--	    // int addr = readOpd16u();
	            	--	    // stack[++sp] = readMem(addr);
	            	--	    // stack[++sp] = readMem(addr+1);
	0352 : 500;		--	   nop opd
	0353 : 500;		--	   nop opd
	0354 : 0f6;		--	   ld_opd_16u
	0355 : 0f8;		--	   dup
	0356 : 042;		--	   stmra
	0357 : 0c9;		--	   ldi 1
	0358 : 004;		--	   add
	0359 : 026;		--	   stm a
	035a : 101;		--	   wait
	035b : 101;		--	   wait
	035c : 0e0;		--	   ldmrd // read high word
	035d : 0a6;		--	   ldm a
	035e : 042;		--	   stmra
	035f : 101;		--	   wait
	0360 : 101;		--	   wait
	0361 : 8e0;		--	   ldmrd nxt // read low word
	            	--	putstatic_long:
	            	--	    // int addr = readOpd16u();
	            	--	    // writeMem(addr+1, stack[sp--]);
	            	--	    // writeMem(addr, stack[sp--]);
	0362 : 427;		--	   stm b opd // save low word
	0363 : 426;		--	   stm a opd // save high word
	            	--	   // could also be done to keep values on
	            	--	   // stack, but first store at addr+1 (like 
	            	--	   // in Java simulation)
	0364 : 0f6;		--	   ld_opd_16u
	0365 : 0f8;		--	   dup
	0366 : 041;		--	   stmwa // write ext. mem address
	0367 : 0a6;		--	   ldm a // restore value
	0368 : 043;		--	   stmwd // write ext. mem data
	0369 : 0c9;		--	   ldi 1
	036a : 004;		--	   add
	036b : 101;		--	   wait
	036c : 101;		--	   wait
	036d : 041;		--	   stmwa
	036e : 0a7;		--	   ldm b
	036f : 043;		--	   stmwd
	0370 : 101;		--	   wait
	0371 : 101;		--	   wait
	0372 : 900;		--	   nop nxt
	            	--	getfield_long:
	            	--	    // int off = readOpd16u();
	            	--	    // int ref = stack[sp];
	            	--	    // if (useHandle) {
	            	--	    //	// handle needs indirection
	            	--	    //	ref = readMem(ref);
	            	--	    // }
	            	--	    // stack[sp] = readMem(ref+off);
	            	--	    // stack[++sp] = readMem(ref+off+1);
	0373 : 0f8;		--	   dup // null pointer check
	0374 : 100;		--	   nop // could be interleaved with
	0375 : 197;		--	   bz long_null_pointer // following code
	0376 : 100;		--	   nop
	0377 : 100;		--	   nop
	0378 : 04d;		--	   stmraf // read handle indirection
	0379 : 101;		--	   wait // for the GC
	037a : 101;		--	   wait
	037b : 0e0;		--	   ldmrd
	037c : 500;		--	   nop opd
	037d : 500;		--	   nop opd
	037e : 0f6;		--	   ld_opd_16u // CP index is the offset for the field
	037f : 004;		--	   add // +objectref
	0380 : 0f8;		--	   dup
	0381 : 04d;		--	   stmraf
	0382 : 0c9;		--	   ldi 1
	0383 : 004;		--	   add
	0384 : 026;		--	   stm a
	0385 : 101;		--	   wait
	0386 : 101;		--	   wait
	0387 : 0e0;		--	   ldmrd // read high word
	0388 : 0a6;		--	   ldm a
	0389 : 04d;		--	   stmraf
	038a : 101;		--	   wait
	038b : 101;		--	   wait
	038c : 8e0;		--	   ldmrd nxt // read low word
	            	--	long_null_pointer:
	038d : 0ce;		--	   ldi io_exc
	038e : 041;		--	   stmwa // write ext. mem address
	038f : 0c6;		--	   ldi exc_np
	0390 : 043;		--	   stmwd // write ext. mem data
	0391 : 101;		--	   wait
	0392 : 101;		--	   wait
	0393 : 900;		--	   nop nxt
	            	--	putfield_long:
	            	--	    // int off = readOpd16u();
	            	--	    // int val_l = stack[sp--];
	            	--	    // int val_h = stack[sp--];
	            	--	    // int ref = stack[sp--];
	            	--	    // if (useHandle) {
	            	--	    // 	// handle needs indirection
	            	--	    // 	ref = readMem(ref);
	            	--	    // }
	            	--	    // writeMem(ref+off, val_h);
	            	--	    // writeMem(ref+off+1, val_l);
	0394 : 027;		--	   stm b // save low word
	0395 : 026;		--	   stm a // save high word
	0396 : 0f8;		--	   dup // null pointer check
	0397 : 100;		--	   nop // could be interleaved with
	0398 : 1b4;		--	   bz long_null_pointer // following code
	0399 : 100;		--	   nop
	039a : 100;		--	   nop
	039b : 04d;		--	   stmraf // read handle indirection
	039c : 101;		--	   wait // for the GC
	039d : 101;		--	   wait
	039e : 0e0;		--	   ldmrd
	039f : 500;		--	   nop opd
	03a0 : 500;		--	   nop opd
	03a1 : 0f6;		--	   ld_opd_16u // CP index is the offset for the field
	03a2 : 004;		--	   add // +objectref
	03a3 : 0f8;		--	   dup
	03a4 : 041;		--	   stmwa // write ext. mem address
	03a5 : 0a6;		--	   ldm a // restore value
	03a6 : 04e;		--	   stmwdf // write ext. mem data
	03a7 : 0c9;		--	   ldi 1
	03a8 : 004;		--	   add
	03a9 : 101;		--	   wait
	03aa : 101;		--	   wait
	03ab : 041;		--	   stmwa
	03ac : 0a7;		--	   ldm b
	03ad : 04e;		--	   stmwdf
	03ae : 101;		--	   wait
	03af : 101;		--	   wait
	03b0 : 900;		--	   nop nxt
	            	--	long_null_pointer_arr_store:
	03b1 : 0ce;		--	   ldi io_exc
	03b2 : 041;		--	   stmwa // write ext. mem address
	03b3 : 0c6;		--	   ldi exc_np
	03b4 : 043;		--	   stmwd // write ext. mem data
	03b5 : 101;		--	   wait
	03b6 : 101;		--	   wait
	03b7 : 900;		--	   nop nxt
	            	--	//
	            	--	//	array bound exception
	            	--	//		now only used by long bytecodes
	            	--	//
	            	--	array_bound_store:
	03b8 : 101;		--	   wait // just for shure if we jump during
	03b9 : 101;		--	   wait // a memory transaction to this point
	03ba : 0ce;		--	   ldi io_exc
	03bb : 041;		--	   stmwa // write ext. mem address
	03bc : 0cc;		--	   ldi exc_ab
	03bd : 043;		--	   stmwd // write ext. mem data
	03be : 101;		--	   wait
	03bf : 101;		--	   wait
	03c0 : 900;		--	   nop nxt
	            	--	dastore:
	            	--	lastore:
	03c1 : 026;		--	   stm a // value_h
	03c2 : 028;		--	   stm c // value_l
	03c3 : 027;		--	   stm b // index
	            	--	   // arrayref is TOS
	03c4 : 0f8;		--	   dup // for null pointer check
	03c5 : 0f8;		--	   dup // for bound check, one cycle wait for bz
	03c6 : 1aa;		--	   bz long_null_pointer_arr_store // 
	            	--	   // we do the following in the
	            	--	   // branch slot -> one more element
	            	--	   // from the former dup on the stack
	03c7 : 0c9;		--	   ldi 1
	03c8 : 004;		--	   add // arrayref+1
	03c9 : 04d;		--	   stmraf // read ext. mem, mem_bsy comes one cycle later
	03ca : 101;		--	   wait // is this ok? - wait in branch slot
	03cb : 101;		--	   wait
	03cc : 0e0;		--	   ldmrd // read ext. mem (array length)
	03cd : 0c9;		--	   ldi 1
	03ce : 005;		--	   sub // length-1
	03cf : 0a7;		--	   ldm b // index
	03d0 : 005;		--	   sub // TOS = length-1-index
	03d1 : 0a7;		--	   ldm b // check if index is negativ
	03d2 : 002;		--	   or // is one of both checks neagtv?
	03d3 : 0d4;		--	          ldi -2147483648 //  0x80000000
	03d4 : 001;		--	   and
	03d5 : 100;		--	   nop
	03d6 : 1e1;		--	   bnz array_bound_store
	03d7 : 100;		--	   nop
	03d8 : 100;		--	   nop
	03d9 : 04d;		--	   stmraf // read handle indirection
	03da : 101;		--	   wait // for the GC
	03db : 101;		--	   wait
	03dc : 0e0;		--	   ldmrd
	03dd : 0a7;		--	   ldm b
	03de : 0c9;		--	   ldi 1
	03df : 01d;		--	   shl // index*2
	03e0 : 004;		--	   add // index*2+arrayref
	03e1 : 029;		--	   stm d
	03e2 : 0a9;		--	   ldm d
	03e3 : 041;		--	   stmwa // write ext. mem address
	03e4 : 0a8;		--	   ldm c
	03e5 : 043;		--	   stmwd // write ext. mem data
	03e6 : 0a9;		--	   ldm d
	03e7 : 0c9;		--	   ldi 1
	03e8 : 004;		--	   add // index*2+arrayref+1
	03e9 : 101;		--	   wait
	03ea : 101;		--	   wait
	03eb : 041;		--	   stmwa // write ext. mem address
	03ec : 0a6;		--	   ldm a
	03ed : 043;		--	   stmwd // write ext. mem data
	03ee : 101;		--	   wait
	03ef : 101;		--	   wait
	03f0 : 900;		--	   nop nxt
	            	--	long_null_pointer_arr:
	03f1 : 0ce;		--	   ldi io_exc
	03f2 : 041;		--	   stmwa // write ext. mem address
	03f3 : 0c6;		--	   ldi exc_np
	03f4 : 043;		--	   stmwd // write ext. mem data
	03f5 : 101;		--	   wait
	03f6 : 101;		--	   wait
	03f7 : 900;		--	   nop nxt
	            	--	//
	            	--	//	array bound exception
	            	--	//		now only used by long bytecodes
	            	--	//
	            	--	array_bound:
	03f8 : 101;		--	   wait // just for shure if we jump during
	03f9 : 101;		--	   wait // a memory transaction to this point
	03fa : 0ce;		--	   ldi io_exc
	03fb : 041;		--	   stmwa // write ext. mem address
	03fc : 0cc;		--	   ldi exc_ab
	03fd : 043;		--	   stmwd // write ext. mem data
	03fe : 101;		--	   wait
	03ff : 101;		--	   wait
	0400 : 900;		--	   nop nxt
	            	--	daload:
	            	--	laload:
	0401 : 027;		--	   stm b // index
	            	--	   // arrayref is TOS
	0402 : 0f8;		--	   dup // for null pointer check
	0403 : 0f8;		--	   dup // for bound check, one cycle wait for bz
	0404 : 1ac;		--	   bz long_null_pointer_arr // we do the following in the
	            	--	   // branch slot -> one more element
	            	--	   // from the former dup on the stack
	0405 : 0c9;		--	   ldi 1
	0406 : 004;		--	   add // arrayref+1
	0407 : 04d;		--	   stmraf // read array length
	0408 : 101;		--	   wait // is this ok? - wait in branch slot
	0409 : 101;		--	   wait
	040a : 0e0;		--	   ldmrd // read ext. mem (array length)er	// 
	040b : 0c9;		--	   ldi 1
	040c : 005;		--	   sub // length-1
	040d : 0a7;		--	   ldm b // index
	040e : 005;		--	   sub // TOS = length-1-index
	040f : 0a7;		--	   ldm b // check if index is negative
	0410 : 002;		--	   or // is one of both checks negative?
	0411 : 0d4;		--	          ldi -2147483648 //  0x80000000
	0412 : 001;		--	   and
	0413 : 100;		--	   nop
	0414 : 1e3;		--	   bnz array_bound
	0415 : 100;		--	   nop
	0416 : 100;		--	   nop
	0417 : 04d;		--	   stmraf // read handle indirection
	0418 : 101;		--	   wait // for the GC
	0419 : 101;		--	   wait
	041a : 0e0;		--	   ldmrd
	041b : 0a7;		--	   ldm b
	041c : 0c9;		--	   ldi 1
	041d : 01d;		--	   shl // index*2
	041e : 004;		--	   add // index*2+arrayref
	041f : 0f8;		--	   dup
	0420 : 029;		--	   stm d
	0421 : 042;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	0422 : 101;		--	   wait
	0423 : 101;		--	   wait
	0424 : 0e0;		--	   ldmrd
	0425 : 0a9;		--	   ldm d
	0426 : 0c9;		--	   ldi 1
	0427 : 004;		--	   add // index*2+arrayref+1
	0428 : 042;		--	   stmra // read ext. mem, mem_bsy comes one cycle later
	0429 : 101;		--	   wait
	042a : 101;		--	   wait
	042b : 8e0;		--	   ldmrd nxt // read ext. mem
	            	--	lneg: // WCET=8+26=34
	042c : 0d0;		--	   ldi -1
	042d : 003;		--	   xor
	042e : 026;		--	   stm a
	042f : 0d0;		--	   ldi -1
	0430 : 003;		--	   xor
	0431 : 0a6;		--	   ldm a
	0432 : 0c3;		--	   ldi 0
	0433 : 0c9;		--	   ldi 1
	            	--	   // fall through to addition
	            	--	ladd: // WCET=26
	0434 : 026;		--	   stm a // bl
	0435 : 027;		--	   stm b // bh
	0436 : 028;		--	   stm c // al
	0437 : 029;		--	   stm d // hh
	0438 : 0a8;		--	   ldm c // al>>>1
	0439 : 0c9;		--	   ldi 1
	043a : 01c;		--	   ushr
	043b : 0a6;		--	   ldm a // bl>>>1
	043c : 0c9;		--	   ldi 1
	043d : 01c;		--	   ushr
	043e : 004;		--	   add // (al>>>1) + (bl>>>1)
	043f : 0a6;		--	   ldm a // (al & bl & 1)
	0440 : 0a8;		--	   ldm c
	0441 : 001;		--	   and
	0442 : 0c9;		--	   ldi 1
	0443 : 001;		--	   and
	0444 : 004;		--	   add // (al>>>1) + (bl>>>1) + (al & bl & 1)
	0445 : 0cf;		--	   ldi 31 // carry, ((al>>>1) + (bl>>>1) + (al & bl & 1)) >>> 31
	0446 : 01c;		--	   ushr
	0447 : 0a7;		--	   ldm b
	0448 : 004;		--	   add
	0449 : 0a9;		--	   ldm d
	044a : 004;		--	   add // ah+bh+carry
	044b : 0a6;		--	   ldm a
	044c : 0a8;		--	   ldm c
	044d : 804;		--	   add nxt
	            	--	lsub: // WCET=38
	044e : 0d0;		--	   ldi -1 // bl = ~bl
	044f : 003;		--	   xor
	0450 : 026;		--	   stm a // bl
	0451 : 0d0;		--	   ldi -1 // bh = ~bh
	0452 : 003;		--	   xor
	0453 : 027;		--	   stm b // bh
	0454 : 028;		--	   stm c // al
	0455 : 029;		--	   stm d // ah
	0456 : 0a8;		--	   ldm c // al>>>1
	0457 : 0c9;		--	   ldi 1
	0458 : 01c;		--	   ushr
	0459 : 0a6;		--	   ldm a // bl>>>1
	045a : 0c9;		--	   ldi 1
	045b : 01c;		--	   ushr
	045c : 004;		--	   add // (al>>>1) + (bl>>>1)
	045d : 0a6;		--	   ldm a // (al&1 + bl&1 + 1)>>1
	045e : 0c9;		--	   ldi 1
	045f : 001;		--	   and
	0460 : 0a8;		--	   ldm c
	0461 : 0c9;		--	   ldi 1
	0462 : 001;		--	   and
	0463 : 004;		--	   add
	0464 : 0c9;		--	   ldi 1
	0465 : 004;		--	   add
	0466 : 0c9;		--	   ldi 1
	0467 : 01e;		--	   shr
	0468 : 004;		--	   add // (al>>>1) + (bl>>>1) + (al&1 + bl&1 + 1)>>1
	0469 : 0cf;		--	   ldi 31
	046a : 01c;		--	   ushr
	046b : 0a7;		--	   ldm b
	046c : 004;		--	   add
	046d : 0a9;		--	   ldm d
	046e : 004;		--	   add // ah+bh+carry
	046f : 0a6;		--	   ldm a
	0470 : 0a8;		--	   ldm c
	0471 : 004;		--	   add
	0472 : 0c9;		--	   ldi 1
	0473 : 804;		--	   add nxt
	            	--	lcmp: // WCET=80 (?)
	0474 : 026;		--	   stm a // bl
	0475 : 027;		--	   stm b // bh
	0476 : 028;		--	   stm c // al
	0477 : 029;		--	   stm d // ah
	            	--	lcmp_chk_overflow1:
	0478 : 0a9;		--	   ldm d // ah < 0
	0479 : 0cf;		--	   ldi 31
	047a : 01e;		--	   shr
	047b : 0a7;		--	   ldm b
	047c : 0cf;		--	   ldi 31 // bh >= 0
	047d : 01e;		--	   shr
	047e : 0d0;		--	   ldi -1
	047f : 003;		--	   xor
	0480 : 002;		--	   or // !(ah < 0 || bh >= 0)
	0481 : 100;		--	   nop
	0482 : 1c3;		--	   bnz lcmp_chk_overflow2
	0483 : 100;		--	   nop
	0484 : 100;		--	   nop
	0485 : 8c9;		--	   ldi 1 nxt
	            	--	lcmp_chk_overflow2:
	0486 : 0a9;		--	   ldm d // ah >= 0
	0487 : 0cf;		--	   ldi 31
	0488 : 01e;		--	   shr
	0489 : 0d0;		--	   ldi -1
	048a : 003;		--	   xor
	048b : 0a7;		--	   ldm b // bh < 0
	048c : 0cf;		--	   ldi 31
	048d : 01e;		--	   shr
	048e : 002;		--	   or // !(ah >= 0 || bh < 0)
	048f : 100;		--	   nop
	0490 : 1c3;		--	   bnz lcmp_sub
	0491 : 100;		--	   nop
	0492 : 100;		--	   nop
	0493 : 8d0;		--	   ldi -1 nxt
	            	--	lcmp_sub:
	0494 : 0a6;		--	   ldm a
	0495 : 0d0;		--	   ldi -1 // bl = ~bl
	0496 : 003;		--	   xor
	0497 : 026;		--	   stm a // bl
	0498 : 0a7;		--	   ldm b
	0499 : 0d0;		--	   ldi -1 // bh = ~bh
	049a : 003;		--	   xor
	049b : 027;		--	   stm b // bh
	049c : 0a8;		--	   ldm c // al>>>1
	049d : 0c9;		--	   ldi 1
	049e : 01c;		--	   ushr
	049f : 0a6;		--	   ldm a // bl>>>1
	04a0 : 0c9;		--	   ldi 1
	04a1 : 01c;		--	   ushr
	04a2 : 004;		--	   add // (al>>>1) + (bl>>>1)
	04a3 : 0a6;		--	   ldm a // (al&1 + bl&1 + 1)>>1
	04a4 : 0c9;		--	   ldi 1
	04a5 : 001;		--	   and
	04a6 : 0a8;		--	   ldm c
	04a7 : 0c9;		--	   ldi 1
	04a8 : 001;		--	   and
	04a9 : 004;		--	   add
	04aa : 0c9;		--	   ldi 1
	04ab : 004;		--	   add
	04ac : 0c9;		--	   ldi 1
	04ad : 01e;		--	   shr
	04ae : 004;		--	   add // (al>>>1) + (bl>>>1) + (al&1 + bl&1 + 1)>>1
	04af : 0cf;		--	   ldi 31
	04b0 : 01c;		--	   ushr
	04b1 : 0a7;		--	   ldm b
	04b2 : 004;		--	   add
	04b3 : 0a9;		--	   ldm d
	04b4 : 004;		--	   add // ah+bh+carry
	04b5 : 029;		--	   stm d // hi(a-b)
	04b6 : 0a6;		--	   ldm a
	04b7 : 0a8;		--	   ldm c
	04b8 : 004;		--	   add
	04b9 : 0c9;		--	   ldi 1
	04ba : 004;		--	   add
	04bb : 028;		--	   stm c // lo(a-b)
	04bc : 0a8;		--	   ldm c
	04bd : 0a9;		--	   ldm d
	04be : 002;		--	   or
	04bf : 100;		--	   nop
	04c0 : 1c3;		--	   bnz lcmp_notequal
	04c1 : 100;		--	   nop
	04c2 : 100;		--	   nop
	04c3 : 8c3;		--	   ldi 0 nxt
	            	--	lcmp_notequal:
	04c4 : 0a9;		--	   ldm d
	04c5 : 0cf;		--	   ldi 31
	04c6 : 01e;		--	   shr
	04c7 : 100;		--	   nop
	04c8 : 1c3;		--	   bnz lcmp_less
	04c9 : 100;		--	   nop
	04ca : 100;		--	   nop
	04cb : 8c9;		--	   ldi 1 nxt
	            	--	lcmp_less:
	04cc : 8d0;		--	   ldi -1 nxt
	            	--	lushr: // WCET=28
	04cd : 0d5;		--	   ldi 63 // cnt &= 0x3f
	04ce : 001;		--	   and
	04cf : 0f8;		--	   dup
	04d0 : 1c4;		--	   bnz lushr_not0
	04d1 : 100;		--	   nop
	04d2 : 100;		--	   nop
	04d3 : 800;		--	   pop nxt
	04d4 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lushr_not0:
	04d5 : 0f8;		--	   dup // cnt > 31?
	04d6 : 0d6;		--	   ldi 32
	04d7 : 005;		--	   sub
	04d8 : 0cf;		--	   ldi 31
	04d9 : 01c;		--	   ushr
	04da : 100;		--	   nop
	04db : 1cc;		--	   bnz lushr_le31
	04dc : 028;		--	   stm c // cnt
	04dd : 026;		--	   stm a // al
	            	--	lushr_gt31:
	04de : 027;		--	   stm b // ah
	04df : 0c3;		--	   ldi 0 // ah = 0
	04e0 : 0a7;		--	   ldm b // al = ah >>> (cnt-32)
	04e1 : 0a8;		--	   ldm c
	04e2 : 0d6;		--	   ldi 32
	04e3 : 005;		--	   sub
	04e4 : 81c;		--	   ushr nxt
	04e5 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	04e6 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	04e7 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lushr_le31:
	04e8 : 027;		--	   stm b // ah
	04e9 : 0a7;		--	   ldm b // ah = ah >>> cnt
	04ea : 0a8;		--	   ldm c
	04eb : 01c;		--	   ushr
	04ec : 0a6;		--	   ldm a // al = (al >>> cnt) + (ah << (32-cnt))
	04ed : 0a8;		--	   ldm c
	04ee : 01c;		--	   ushr
	04ef : 0a7;		--	   ldm b
	04f0 : 0d6;		--	   ldi 32
	04f1 : 0a8;		--	   ldm c
	04f2 : 005;		--	   sub
	04f3 : 01d;		--	   shl
	04f4 : 804;		--	   add nxt
	            	--	lshr: // WCET=28
	04f5 : 0d5;		--	   ldi 63 // cnt &= 0x3f
	04f6 : 001;		--	   and
	04f7 : 0f8;		--	   dup
	04f8 : 1c4;		--	   bnz lshr_not0
	04f9 : 100;		--	   nop
	04fa : 100;		--	   nop
	04fb : 800;		--	   pop nxt
	04fc : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lshr_not0:
	04fd : 0f8;		--	   dup // cnt > 31?
	04fe : 0d6;		--	   ldi 32
	04ff : 005;		--	   sub
	0500 : 0cf;		--	   ldi 31
	0501 : 01c;		--	   ushr
	0502 : 100;		--	   nop
	0503 : 1cc;		--	   bnz lshr_le31
	0504 : 028;		--	   stm c // cnt
	0505 : 026;		--	   stm a // al
	            	--	lshr_gt31:
	0506 : 027;		--	   stm b // ah
	0507 : 0a7;		--	   ldm b // ah = ah >> 31
	0508 : 0cf;		--	   ldi 31
	0509 : 01e;		--	   shr
	050a : 0a7;		--	   ldm b // al = ah >> (cnt-32)
	050b : 0a8;		--	   ldm c
	050c : 0d6;		--	   ldi 32
	050d : 005;		--	   sub
	050e : 81e;		--	   shr nxt
	050f : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lshr_le31:
	0510 : 027;		--	   stm b // ah
	0511 : 0a7;		--	   ldm b // ah = ah >> cnt
	0512 : 0a8;		--	   ldm c
	0513 : 01e;		--	   shr
	0514 : 0a6;		--	   ldm a // al = (al >>> cnt) + (ah << (32-cnt))
	0515 : 0a8;		--	   ldm c
	0516 : 01c;		--	   ushr
	0517 : 0a7;		--	   ldm b
	0518 : 0d6;		--	   ldi 32
	0519 : 0a8;		--	   ldm c
	051a : 005;		--	   sub
	051b : 01d;		--	   shl
	051c : 804;		--	   add nxt
	            	--	lshl: // WCET=28
	051d : 0d5;		--	   ldi 63 // cnt &= 0x3f
	051e : 001;		--	   and
	051f : 0f8;		--	   dup
	0520 : 1c4;		--	   bnz lshl_not0
	0521 : 100;		--	   nop
	0522 : 100;		--	   nop
	0523 : 800;		--	   pop nxt
	0524 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lshl_not0:
	0525 : 0f8;		--	   dup // cnt > 31?
	0526 : 0d6;		--	   ldi 32
	0527 : 005;		--	   sub
	0528 : 0cf;		--	   ldi 31
	0529 : 01c;		--	   ushr
	052a : 100;		--	   nop
	052b : 1cc;		--	   bnz lshl_le31
	052c : 028;		--	   stm c // cnt
	052d : 026;		--	   stm a // al
	            	--	lshl_gt31:
	052e : 027;		--	   stm b // ah
	052f : 0a6;		--	   ldm a // ah = al << (cnt-32)
	0530 : 0a8;		--	   ldm c
	0531 : 0d6;		--	   ldi 32
	0532 : 005;		--	   sub
	0533 : 01d;		--	   shl
	0534 : 8c3;		--	   ldi 0 nxt // al = 0
	0535 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	0536 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	0537 : 100;		--	   nop // dummy nop to keep offtbl.vhd happy
	            	--	lshl_le31:
	0538 : 027;		--	   stm b // ah
	0539 : 0a7;		--	   ldm b // ah = (ah << cnt) + (al >>> (32-cnt))
	053a : 0a8;		--	   ldm c
	053b : 01d;		--	   shl
	053c : 0a6;		--	   ldm a
	053d : 0d6;		--	   ldi 32
	053e : 0a8;		--	   ldm c
	053f : 005;		--	   sub
	0540 : 01c;		--	   ushr
	0541 : 004;		--	   add
	0542 : 0a6;		--	   ldm a // al = al << cnt
	0543 : 0a8;		--	   ldm c
	0544 : 81d;		--	   shl nxt
	            	--	lxor: // WCET=8
	0545 : 026;		--	   stm a
	0546 : 027;		--	   stm b
	0547 : 028;		--	   stm c
	0548 : 0a7;		--	   ldm b
	0549 : 003;		--	   xor
	054a : 0a6;		--	   ldm a
	054b : 0a8;		--	   ldm c
	054c : 803;		--	   xor nxt
	            	--	land: // WCET=8
	054d : 026;		--	   stm a
	054e : 027;		--	   stm b
	054f : 028;		--	   stm c
	0550 : 0a7;		--	   ldm b
	0551 : 001;		--	   and
	0552 : 0a6;		--	   ldm a
	0553 : 0a8;		--	   ldm c
	0554 : 801;		--	   and nxt
	            	--	lor: // WCET=8
	0555 : 026;		--	   stm a
	0556 : 027;		--	   stm b
	0557 : 028;		--	   stm c
	0558 : 0a7;		--	   ldm b
	0559 : 002;		--	   or
	055a : 0a6;		--	   ldm a
	055b : 0a8;		--	   ldm c
	055c : 802;		--	   or nxt
	            	--	//****************
	            	--	// recop communication
	            	--	jopsys_dcall:
	055d : 8f9;		--	   lddcall nxt // read datacall
	            	--	jopsys_cdresult:
	055e : 817;		--	   wrdprr nxt // write dprr
	            	--	//****************
	            	--	// special byte codes for native functions
	            	--	//jopsys_rd:
	            	--	//			stioa		// io-address
	            	--	//			nop
	            	--	//			ldiod	nxt	// read data
	            	--	//
	            	--	//jopsys_wr:
	            	--	//			stioa		// io-address
	            	--	//			nop
	            	--	//			stiod	nxt	// write data
	            	--	//
	            	--	//	this sequence takes ram_cnt + 3 cycles
	            	--	//	means ram_cnt-1 wait states (bsy)
	            	--	//	nws = ram_cnt-1
	            	--	//
	            	--	//	or in other words 4+nws
	            	--	//
	            	--	//	For the 100MHz JOP version this sequnce takes
	            	--	//	5 cycles.
	            	--	//
	            	--	//
	            	--	jopsys_rd:
	            	--	jopsys_rdmem:
	055f : 042;		--	   stmra // read memory, mem_bsy comes one cycle later
	0560 : 101;		--	   wait
	0561 : 101;		--	   wait // execute 1+nws
	0562 : 8e0;		--	   ldmrd nxt // read ext. mem
	            	--	//
	            	--	//	The wait states for the write are the same as
	            	--	//	for the read: nws = ram_cnt-1
	            	--	//
	            	--	//	The sequence executes for 5+nws cycles - for the
	            	--	//	100MHz version in 6 cycles
	            	--	//
	            	--	jopsys_wr:
	            	--	jopsys_wrmem:
	0563 : 041;		--	   stmwa // store memory address
	0564 : 043;		--	   stmwd // store memory data
	0565 : 101;		--	   wait
	0566 : 101;		--	   wait // execute 1+nws
	0567 : 900;		--	   nop nxt
	            	--	jopsys_rdint:
	0568 : 01a;		--	   star // address in ar
	0569 : 100;		--	   nop // due to pipelining
	056a : 8ed;		--	   ldmi nxt // read value (ar indirect)
	            	--	jopsys_wrint:
	056b : 01a;		--	   star // address in ar
	056c : 100;		--	   nop // due to pipelining
	056d : 815;		--	   stmi nxt // write value (ar indirect)
	            	--	jopsys_getsp:
	056e : 0f0;		--	   ldsp // one increment but still one to low ('real' sp is sp+2 because of registers)
	056f : 0c9;		--	   ldi 1 // 'real' sp			da sp auf rd adr zeigt
	0570 : 804;		--	   add nxt
	            	--	jopsys_setsp:
	0571 : 100;		--	   nop // written in adr/read stage!
	0572 : 01b;		--	   stsp // new sp
	0573 : 000;		--	   pop // flash tos, tos-1 (registers)
	0574 : 800;		--	   pop nxt // sp must be two lower, points to rd adr
	            	--	jopsys_getvp:
	0575 : 8f1;		--	   ldvp nxt
	            	--	jopsys_setvp:
	0576 : 018;		--	   stvp
	0577 : 900;		--	   nop nxt
	            	--	// public static native void int2extMem(int intAdr, int extAdr, int cnt);
	            	--	jopsys_int2ext:
	0578 : 0d0;		--	   ldi -1
	0579 : 004;		--	   add
	057a : 028;		--	   stm c // counter-1
	057b : 042;		--	   stmra // read handle indirection
	057c : 027;		--	   stm b // intern address
	057d : 101;		--	   wait // for the GC
	057e : 101;		--	   wait
	057f : 0e0;		--	   ldmrd
	0580 : 026;		--	   stm a // extern address
	0581 : 0a8;		--	   ldm c // keep counter on the stack
	            	--	intext_loop:
	0582 : 0f8;		--	   dup
	0583 : 0a7;		--	   ldm b
	0584 : 004;		--	   add
	0585 : 01a;		--	   star
	0586 : 0f8;		--	   dup
	0587 : 0a6;		--	   ldm a
	0588 : 004;		--	   add
	0589 : 041;		--	   stmwa
	058a : 0ed;		--	   ldmi
	058b : 043;		--	   stmwd
	058c : 0f8;		--	   dup
	058d : 101;		--	   wait
	058e : 101;		--	   wait
	058f : 1f2;		--	   bnz intext_loop
	0590 : 0d0;		--	   ldi -1 // decrement in branch slot
	0591 : 004;		--	   add
	0592 : 800;		--	   pop nxt // remove counter
	            	--	// public static native void ext2intMem(int extAdr, int intAdr, int cnt);
	            	--	jopsys_ext2int:
	0593 : 0d0;		--	   ldi -1
	0594 : 004;		--	   add
	0595 : 028;		--	   stm c // counter-1
	0596 : 027;		--	   stm b // intern address
	0597 : 042;		--	   stmra // read handle indirection
	0598 : 101;		--	   wait // for the GC
	0599 : 101;		--	   wait
	059a : 0e0;		--	   ldmrd
	059b : 026;		--	   stm a // extern address
	059c : 0a8;		--	   ldm c // keep counter on the stack
	            	--	extint_loop:
	059d : 0f8;		--	   dup
	059e : 0a6;		--	   ldm a
	059f : 004;		--	   add
	05a0 : 042;		--	   stmra
	05a1 : 0f8;		--	   dup
	05a2 : 0a7;		--	   ldm b
	05a3 : 004;		--	   add
	05a4 : 01a;		--	   star
	05a5 : 101;		--	   wait
	05a6 : 101;		--	   wait
	05a7 : 0e0;		--	   ldmrd // read ext val
	05a8 : 015;		--	   stmi
	05a9 : 0f8;		--	   dup
	05aa : 100;		--	   nop
	05ab : 1f1;		--	   bnz extint_loop
	05ac : 0d0;		--	   ldi -1 // decrement in branch slot
	05ad : 004;		--	   add
	05ae : 800;		--	   pop nxt // remove counter
	            	--	//	public static native void memCopy(int src, int dest, int cnt);
	            	--	jopsys_memcpy:
	            	--	// 			ldi	-1
	            	--	// 			add
	            	--	// 			stm c	// counter-1
	            	--	// 			stm b	// destination
	            	--	// 			stm a	// source
	            	--	// 			ldm	c	// keep counter on the stack
	            	--	// memcpy_loop:
	            	--	// 			dup
	            	--	// 			ldm	a
	            	--	// 			add
	            	--	// 			stmra
	            	--	// 			dup
	            	--	// 			ldm	b
	            	--	// 			add
	            	--	// 			stmwa	// should be ok
	            	--	// 			wait
	            	--	// 			wait
	            	--	// 			ldmrd
	            	--	// 			stmwd
	            	--	// 			dup
	            	--	// 			wait
	            	--	// 			wait
	            	--	// 			bnz	memcpy_loop
	            	--	// 			ldi	-1	// decrement in branch slot
	            	--	// 			add
	05af : 048;		--	   stcp
	05b0 : 000;		--	   pop
	05b1 : 101;		--	   wait
	05b2 : 101;		--	   wait
	05b3 : 800;		--	   pop nxt
	            	--	//
	            	--	//	some conversions only need a nop!
	            	--	//
	            	--	jopsys_nop:
	05b4 : 900;		--	   nop nxt
	            	--	//jopsys_invoke: see invoke
	            	--	jopsys_cond_move:
	05b5 : 100;		--	   nop // one cycle for the condition
	05b6 : 183;		--	   bz false_path
	05b7 : 027;		--	   stm b
	05b8 : 028;		--	   stm c
	05b9 : 8a8;		--	   ldm c nxt
	05ba : 8a7;		--	false_path: ldm b nxt
	            	--	// invalidate cache coherent data cache
	            	--	// if we would do it in a single cycle, would the
	            	--	// invalidate signal come to late for the hit detection
	            	--	// earlier in the pipeline?
	            	--	jopsys_inval:
	05bb : 111;		--	   cinval
	05bc : 100;		--	   nop
	05bd : 100;		--	   nop
	05be : 900;		--	   nop nxt

end;
